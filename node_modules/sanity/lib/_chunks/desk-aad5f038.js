'use strict';

var icons = require('@sanity/icons');
var React = require('react');
var jsxRuntime = require('react/jsx-runtime');
var sanity = require('sanity');
var ui = require('@sanity/ui');
var styled = require('styled-components');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');
var CopyToClipboard = require('react-copy-to-clipboard');
var isNumber = require('lodash/isNumber.js');
var isString = require('lodash/isString.js');
var reactRx = require('react-rx');
var router$1 = require('sanity/router');
var omit = require('lodash/omit.js');
var PathUtils = require('@sanity/util/paths');
var uniqBy = require('lodash/uniqBy.js');
var negate = require('lodash/negate.js');
var types = require('@sanity/types');
var uuid = require('@sanity/uuid');
var dateFns = require('date-fns');
var upperFirst = require('lodash/upperFirst.js');
var isHotkey = require('is-hotkey');
var _internal = require('@sanity/schema/_internal');
var camelCase = require('lodash/camelCase.js');
var speakingurl = require('speakingurl');
var uniq = require('lodash/uniq.js');
var kebabCase = require('lodash/kebabCase.js');
var generateHelpUrl = require('@sanity/generate-help-url');
var pickBy = require('lodash/pickBy.js');
var find = require('lodash/find.js');
var uniqueId = require('lodash/uniqueId.js');
var reactIs = require('react-is');
var startCase = require('lodash/startCase.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var React__default = /*#__PURE__*/_interopDefaultCompat(React);
var styled__default = /*#__PURE__*/_interopDefaultCompat(styled);
var CopyToClipboard__default = /*#__PURE__*/_interopDefaultCompat(CopyToClipboard);
var isNumber__default = /*#__PURE__*/_interopDefaultCompat(isNumber);
var isString__default = /*#__PURE__*/_interopDefaultCompat(isString);
var omit__default = /*#__PURE__*/_interopDefaultCompat(omit);
var uniqBy__default = /*#__PURE__*/_interopDefaultCompat(uniqBy);
var negate__default = /*#__PURE__*/_interopDefaultCompat(negate);
var upperFirst__default = /*#__PURE__*/_interopDefaultCompat(upperFirst);
var isHotkey__default = /*#__PURE__*/_interopDefaultCompat(isHotkey);
var camelCase__default = /*#__PURE__*/_interopDefaultCompat(camelCase);
var speakingurl__default = /*#__PURE__*/_interopDefaultCompat(speakingurl);
var uniq__default = /*#__PURE__*/_interopDefaultCompat(uniq);
var kebabCase__default = /*#__PURE__*/_interopDefaultCompat(kebabCase);
var pickBy__default = /*#__PURE__*/_interopDefaultCompat(pickBy);
var find__default = /*#__PURE__*/_interopDefaultCompat(find);
var uniqueId__default = /*#__PURE__*/_interopDefaultCompat(uniqueId);
var startCase__default = /*#__PURE__*/_interopDefaultCompat(startCase);
function Delay(_ref) {
  let {
    children,
    ms = 0
  } = _ref;
  const [ready, setReady] = React.useState(ms <= 0);
  React.useEffect(() => {
    if (ms <= 0) {
      return void 0;
    }
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]);
  if (!ready || !children) {
    return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {});
  }
  return typeof children === "function" ? children() : children;
}
function DocTitle(props) {
  const {
    document: documentValue
  } = props;
  const schema = sanity.useSchema();
  const schemaType = schema.get(documentValue._type);
  const {
    error,
    value
  } = sanity.unstable_useValuePreview({
    schemaType,
    value: documentValue
  });
  if (!schemaType) {
    return /* @__PURE__ */jsxRuntime.jsxs("code", {
      children: ["Unknown schema type: ", documentValue._type]
    });
  }
  if (error) {
    return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: ["Error: ", error.message]
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: (value == null ? void 0 : value.title) || /* @__PURE__ */jsxRuntime.jsx("span", {
      style: {
        color: "var(--card-muted-fg-color)"
      },
      children: "Untitled"
    })
  });
}
function TimeAgo(_ref2) {
  let {
    time
  } = _ref2;
  const timeAgo = sanity.useTimeAgo(time);
  return /* @__PURE__ */jsxRuntime.jsxs("span", {
    title: timeAgo,
    children: [timeAgo, " ago"]
  });
}
function isClientError(e) {
  if (typeof e !== "object") return false;
  if (!e) return false;
  return "statusCode" in e && "response" in e;
}
const POLL_INTERVAL = 5e3;
let visiblePoll$;
const getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = rxjs.fromEvent(document, "visibilitychange").pipe(
    // add empty emission to have this fire on creation
    operators.startWith(null), operators.map(() => document.visibilityState === "visible"), operators.distinctUntilChanged(), operators.switchMap(visible => visible ?
    // using timer instead of interval since timer will emit on creation
    rxjs.timer(0, POLL_INTERVAL) : rxjs.EMPTY), operators.shareReplay({
      refCount: true,
      bufferSize: 1
    }));
  }
  return visiblePoll$;
};
function getDocumentExistence(documentId, _ref3) {
  let {
    versionedClient
  } = _ref3;
  const draftId = sanity.getDraftId(documentId);
  const publishedId = sanity.getPublishedId(documentId);
  const requestOptions = {
    uri: versionedClient.getDataUrl("doc", "".concat(draftId, ",").concat(publishedId)),
    json: true,
    query: {
      excludeContent: "true"
    },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(operators.map(_ref4 => {
    let {
      omitted
    } = _ref4;
    const nonExistant = omitted.filter(doc => doc.reason === "existence");
    if (nonExistant.length === 2) {
      return void 0;
    }
    if (nonExistant.length === 0) {
      return publishedId;
    }
    return nonExistant.some(doc => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const {
    versionedClient
  } = context;
  return getVisiblePoll$().pipe(operators.switchMap(() => getDocumentExistence(documentId, context)), operators.switchMap(checkDocumentId => {
    if (!checkDocumentId) {
      return rxjs.of({
        totalCount: 0,
        references: []
      });
    }
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({
      url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"),
      tag: "use-referring-documents.external"
    }).pipe(operators.catchError(e => {
      if (isClientError(e) && e.statusCode === 404) {
        return rxjs.of({
          totalCount: 0,
          references: []
        });
      }
      throw e;
    }));
  }));
}
const useInternalReferences = sanity.createHookFromObservableFactory(_ref5 => {
  let [documentId, documentStore] = _ref5;
  const referencesClause = "*[references($documentId)][0...100]{_id,_type}";
  const totalClause = "count(*[references($documentId)])";
  const fetchQuery = '{"references":'.concat(referencesClause, ',"totalCount":').concat(totalClause, "}");
  const listenQuery = "*[references($documentId)]";
  return documentStore.listenQuery({
    fetch: fetchQuery,
    listen: listenQuery
  }, {
    documentId
  }, {
    tag: "use-referring-documents",
    transitions: ["appear", "disappear"],
    throttleTime: 5e3
  });
});
const useCrossDatasetReferences = sanity.createHookFromObservableFactory(_ref6 => {
  let [documentId, versionedClient] = _ref6;
  return getVisiblePoll$().pipe(operators.switchMap(() => fetchCrossDatasetReferences(documentId, {
    versionedClient
  })));
});
function useReferringDocuments(documentId) {
  const versionedClient = sanity.useClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS);
  const documentStore = sanity.useDocumentStore();
  const publishedId = sanity.getPublishedId(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences(React.useMemo(() => [publishedId, documentStore], [documentStore, publishedId]));
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(React.useMemo(() => [publishedId, versionedClient], [publishedId, versionedClient]));
  const projectIds = React.useMemo(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map(crossDatasetReference => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const datasetNames = React.useMemo(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map(crossDatasetReference => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter(datasetName => Boolean(datasetName) && datasetName !== ""))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const hasUnknownDatasetNames = React.useMemo(() => {
    return Boolean(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.some(crossDatasetReference => typeof crossDatasetReference.datasetName !== "string"));
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
function PublishedStatus(props) {
  const {
    document
  } = props;
  const updatedAt = document && "_updatedAt" in document && document._updatedAt;
  const statusLabel = document ? "Published" : "Not published";
  return /* @__PURE__ */jsxRuntime.jsx(ui.Tooltip, {
    portal: true,
    content: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      padding: 2,
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        size: 1,
        children: document ? /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: ["Published ", updatedAt && /* @__PURE__ */jsxRuntime.jsx(TimeAgo, {
            time: updatedAt
          })]
        }) : /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
          children: "Not published"
        })
      })
    }),
    children: /* @__PURE__ */jsxRuntime.jsx(sanity.TextWithTone, {
      tone: "positive",
      dimmed: !document,
      muted: !document,
      size: 1,
      children: /* @__PURE__ */jsxRuntime.jsx(icons.PublishIcon, {
        "aria-label": statusLabel
      })
    })
  });
}
function DraftStatus(props) {
  const {
    document
  } = props;
  const updatedAt = document && "_updatedAt" in document && document._updatedAt;
  return /* @__PURE__ */jsxRuntime.jsx(ui.Tooltip, {
    portal: true,
    content: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      padding: 2,
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        size: 1,
        children: document ? /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: ["Edited ", updatedAt && /* @__PURE__ */jsxRuntime.jsx(TimeAgo, {
            time: updatedAt
          })]
        }) : /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
          children: "No unpublished edits"
        })
      })
    }),
    children: /* @__PURE__ */jsxRuntime.jsx(sanity.TextWithTone, {
      tone: "caution",
      dimmed: !document,
      muted: !document,
      size: 1,
      children: /* @__PURE__ */jsxRuntime.jsx(icons.EditIcon, {})
    })
  });
}
function PaneItemPreview(props) {
  const {
    icon,
    layout,
    presence,
    schemaType,
    value
  } = props;
  const title = sanity.isRecord(value.title) && React.isValidElement(value.title) || isString__default.default(value.title) || isNumber__default.default(value.title) ? value.title : null;
  const {
    draft,
    published,
    isLoading
  } = reactRx.useMemoObservable(() => sanity.getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title), [props.documentPreviewStore, schemaType, value._id, title]);
  const status = isLoading ? null : /* @__PURE__ */jsxRuntime.jsxs(ui.Inline, {
    space: 4,
    children: [presence && presence.length > 0 && /* @__PURE__ */jsxRuntime.jsx(sanity.DocumentPreviewPresence, {
      presence
    }), /* @__PURE__ */jsxRuntime.jsx(PublishedStatus, {
      document: published
    }), /* @__PURE__ */jsxRuntime.jsx(DraftStatus, {
      document: draft
    })]
  });
  return /* @__PURE__ */jsxRuntime.jsx(sanity.SanityDefaultPreview, {
    ...sanity.getPreviewValueWithFallback({
      value,
      draft,
      published
    }),
    isPlaceholder: isLoading,
    icon,
    layout,
    status
  });
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
const PaneRouterContext = React.createContext({
  index: 0,
  groupIndex: 0,
  siblingIndex: 0,
  payload: void 0,
  params: {},
  hasGroupSiblings: false,
  groupLength: 0,
  routerPanesState: [],
  BackLink: () => missingContext(),
  ChildLink: () => missingContext(),
  ReferenceChildLink: () => missingContext(),
  handleEditReference: () => missingContext(),
  ParameterizedLink: () => missingContext(),
  replaceCurrent: () => missingContext(),
  closeCurrentAndAfter: () => missingContext(),
  closeCurrent: () => missingContext(),
  duplicateCurrent: () => missingContext(),
  setView: () => missingContext(),
  setParams: () => missingContext(),
  setPayload: () => missingContext(),
  navigateIntent: () => missingContext()
});
const BackLink = React.forwardRef(function BackLink2(props, ref) {
  const {
    routerPanesState,
    groupIndex
  } = React.useContext(PaneRouterContext);
  const panes = React.useMemo(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]);
  const state = React.useMemo(() => ({
    panes
  }), [panes]);
  return /* @__PURE__ */jsxRuntime.jsx(router$1.StateLink, {
    ...props,
    ref,
    state
  });
});
const PaneLayoutContext = React.createContext(null);
function usePaneLayout() {
  const pane = React.useContext(PaneLayoutContext);
  if (!pane) {
    throw new Error("PaneLayout: missing context value");
  }
  return pane;
}
const ChildLink = React.forwardRef(function ChildLink2(props, ref) {
  const {
    childId,
    childPayload,
    childParameters,
    ...rest
  } = props;
  const {
    routerPanesState,
    groupIndex
  } = React.useContext(PaneRouterContext);
  return /* @__PURE__ */jsxRuntime.jsx(router$1.StateLink, {
    ...rest,
    ref,
    state: {
      panes: [...routerPanesState.slice(0, groupIndex + 1), [{
        id: childId,
        params: childParameters,
        payload: childPayload
      }]]
    }
  });
});
const ReferenceChildLink = React.forwardRef(function ReferenceChildLink2(_ref7, ref) {
  let {
    documentId,
    documentType,
    parentRefPath,
    children,
    template,
    ...rest
  } = _ref7;
  return /* @__PURE__ */jsxRuntime.jsx(ChildLink, {
    ...rest,
    ref,
    childId: documentId,
    childPayload: template == null ? void 0 : template.params,
    childParameters: {
      type: documentType,
      parentRefPath: PathUtils.toString(parentRefPath),
      ...(template && {
        template: template == null ? void 0 : template.id
      })
    },
    children
  });
});
const ParameterizedLink = React.forwardRef(function ParameterizedLink2(props, ref) {
  const {
    routerPanesState: currentPanes,
    groupIndex,
    siblingIndex
  } = React.useContext(PaneRouterContext);
  const {
    params,
    payload,
    ...rest
  } = props;
  const nextParams = sanity.useUnique(params);
  const nextPayload = sanity.useUnique(payload);
  const nextState = React.useMemo(() => {
    const currentGroup = currentPanes[groupIndex];
    const currentSibling = currentGroup[siblingIndex];
    const nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    };
    const nextGroup = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)];
    const nextPanes = [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)];
    return {
      panes: nextPanes
    };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return /* @__PURE__ */jsxRuntime.jsx(router$1.StateLink, {
    ref,
    ...rest,
    state: nextState
  });
});
function usePaneRouter() {
  return React.useContext(PaneRouterContext);
}
const EMPTY_ARRAY = [];
function ReferencePreviewLink(props) {
  const {
    onClick,
    type,
    value
  } = props;
  const publishedId = sanity.getPublishedId(value == null ? void 0 : value._id);
  const documentPresence = sanity.useDocumentPresence(publishedId);
  const documentPreviewStore = sanity.useDocumentPreviewStore();
  const {
    ReferenceChildLink
  } = usePaneRouter();
  const Link = React.useCallback(function LinkComponent(linkProps) {
    return /* @__PURE__ */jsxRuntime.jsx(ReferenceChildLink, {
      documentId: value == null ? void 0 : value._id,
      documentType: type == null ? void 0 : type.name,
      parentRefPath: EMPTY_ARRAY,
      ...linkProps
    });
  }, [ReferenceChildLink, type == null ? void 0 : type.name, value == null ? void 0 : value._id]);
  return /* @__PURE__ */jsxRuntime.jsx(sanity.PreviewCard, {
    __unstable_focusRing: true,
    as: Link,
    "data-as": "a",
    onClick,
    padding: 2,
    radius: 2,
    children: /* @__PURE__ */jsxRuntime.jsx(PaneItemPreview, {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "default",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY,
      schemaType: type,
      value
    })
  });
}
var __freeze$d = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$s(cooked, "raw", {
  value: __freeze$d(raw || cooked.slice())
}));
var _a$d, _b$5, _c$3, _d$3, _e$2;
const ChevronWrapper = styled__default.default(ui.Box)(_a$d || (_a$d = __template$d(["\n  margin-left: auto;\n"])));
const CrossDatasetReferencesDetails = styled__default.default.details(_b$5 || (_b$5 = __template$d(["\n  flex: none;\n\n  &[open] ", " {\n    transform: rotate(180deg);\n  }\n"])), ChevronWrapper);
const CrossDatasetReferencesSummary = styled__default.default.summary(_c$3 || (_c$3 = __template$d(["\n  list-style: none;\n\n  &::-webkit-details-marker {\n    display: none;\n  }\n"])));
const Table = styled__default.default.table(_d$3 || (_d$3 = __template$d(["\n  width: 100%;\n  text-align: left;\n  padding: 0 ", ";\n  border-collapse: collapse;\n\n  th {\n    padding: ", ";\n  }\n\n  td {\n    padding: 0 ", ";\n  }\n\n  tr > *:last-child {\n    text-align: right;\n  }\n"])), _ref8 => {
  let {
    theme
  } = _ref8;
  return ui.rem(theme.sanity.space[2]);
}, _ref9 => {
  let {
    theme
  } = _ref9;
  return ui.rem(theme.sanity.space[1]);
}, _ref10 => {
  let {
    theme
  } = _ref10;
  return ui.rem(theme.sanity.space[1]);
});
const DocumentIdFlex = styled__default.default(ui.Flex)(_e$2 || (_e$2 = __template$d(["\n  min-height: 35px;\n"])));
const OtherReferenceCount = props => {
  const difference = props.totalCount - props.references.length;
  if (!difference) return null;
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Inline, {
    space: 2,
    children: [/* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
      size: 1,
      muted: true,
      children: [difference, " other reference", difference === 1 ? "" : "s", " not shown", " "]
    }), /* @__PURE__ */jsxRuntime.jsx(ui.Tooltip, {
      portal: true,
      placement: "top",
      content: /* @__PURE__ */jsxRuntime.jsx(ui.Container, {
        width: 0,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          padding: 2,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            size: 1,
            children: "We can't show metadata about these references because no token with access to the datasets they are in was found."
          })
        })
      }),
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        size: 1,
        muted: true,
        children: /* @__PURE__ */jsxRuntime.jsx(icons.InfoOutlineIcon, {})
      })
    })]
  });
};
function ConfirmDeleteDialogBody(_ref11) {
  let {
    crossDatasetReferences,
    internalReferences,
    documentTitle,
    totalCount,
    action,
    datasetNames,
    hasUnknownDatasetNames,
    onReferenceLinkClick
  } = _ref11;
  const schema = sanity.useSchema();
  const toast = ui.useToast();
  const renderPreviewItem = React.useCallback(item => {
    const type = schema.get(item._type);
    if (type) {
      return /* @__PURE__ */jsxRuntime.jsx(ReferencePreviewLink, {
        type,
        value: item,
        onClick: onReferenceLinkClick
      });
    }
    return (
      // Padding added to match the ReferencePreviewLink styling
      /* @__PURE__ */
      jsxRuntime.jsx(ui.Box, {
        padding: 2,
        children: /* @__PURE__ */jsxRuntime.jsx(sanity.SanityDefaultPreview, {
          icon: icons.UnknownIcon,
          title: "Preview Unavailable",
          subtitle: "ID: ".concat(item._id),
          layout: "default"
        })
      })
    );
  }, [schema, onReferenceLinkClick]);
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0) {
    return /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
      as: "p",
      children: ["Are you sure you want to ", action, " ", /* @__PURE__ */jsxRuntime.jsxs("strong", {
        children: ["\u201C", documentTitle, "\u201D"]
      }), "?"]
    });
  }
  const documentCount = crossDatasetReferences.totalCount === 1 ? "1 document" : "".concat(crossDatasetReferences.totalCount.toLocaleString(), " documents");
  const normalizedDatasetNames = [...datasetNames, ...(hasUnknownDatasetNames ? ["unavailable"] : [])];
  const datasetsCount = normalizedDatasetNames.length === 1 ? "another dataset" : "".concat(normalizedDatasetNames.length, " datasets");
  let datasetNameList = "Dataset".concat(normalizedDatasetNames.length === 1 ? "" : "s", ": ").concat(normalizedDatasetNames.join(", "));
  if (hasUnknownDatasetNames && normalizedDatasetNames.length === 1) {
    datasetNameList = "Unavailable dataset";
  }
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Card, {
    children: [/* @__PURE__ */jsxRuntime.jsx(ui.Card, {
      padding: 3,
      radius: 2,
      tone: "caution",
      marginBottom: 4,
      flex: "none",
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        children: [/* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          "aria-hidden": "true",
          size: 1,
          children: /* @__PURE__ */jsxRuntime.jsx(icons.WarningOutlineIcon, {})
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          flex: 1,
          marginLeft: 3,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            size: 1,
            children: totalCount === 1 ? /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
              children: ["1 document refers to \u201C", documentTitle, "\u201D"]
            }) : /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
              children: [totalCount.toLocaleString(), " documents refer to \u201C", documentTitle, "\u201D"]
            })
          })
        })]
      })
    }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      flex: "none",
      marginBottom: 4,
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
        children: ["You may not be able to ", action, " \u201C", documentTitle, "\u201D because the following documents refer to it:"]
      })
    }), /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
      radius: 2,
      shadow: 1,
      marginBottom: 4,
      flex: "auto",
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        direction: "column",
        children: [internalReferences.totalCount > 0 && /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
          as: "ul",
          padding: 2,
          space: 3,
          "data-testid": "internal-references",
          children: [internalReferences == null ? void 0 : internalReferences.references.map(item => /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
            as: "li",
            children: renderPreviewItem(item)
          }, item._id)), internalReferences.totalCount > internalReferences.references.length && /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
            as: "li",
            padding: 3,
            children: /* @__PURE__ */jsxRuntime.jsx(OtherReferenceCount, {
              ...internalReferences
            })
          })]
        }), crossDatasetReferences.totalCount > 0 && /* @__PURE__ */jsxRuntime.jsxs(CrossDatasetReferencesDetails, {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [/* @__PURE__ */jsxRuntime.jsx(CrossDatasetReferencesSummary, {
            children: /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
              as: "a",
              margin: 2,
              radius: 2,
              shadow: 1,
              paddingY: 1,
              children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
                align: "center",
                margin: 2,
                children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
                  marginLeft: 3,
                  marginRight: 4,
                  children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                    size: 3,
                    children: /* @__PURE__ */jsxRuntime.jsx(icons.DocumentsIcon, {})
                  })
                }), /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
                  marginRight: 4,
                  direction: "column",
                  children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
                    marginBottom: 2,
                    children: /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
                      children: [documentCount, " in ", datasetsCount]
                    })
                  }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
                    children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                      title: datasetNameList,
                      textOverflow: "ellipsis",
                      size: 1,
                      muted: true,
                      children: datasetNameList
                    })
                  })]
                }), /* @__PURE__ */jsxRuntime.jsx(ChevronWrapper, {
                  children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                    muted: true,
                    children: /* @__PURE__ */jsxRuntime.jsx(icons.ChevronDownIcon, {})
                  })
                })]
              })
            })
          }), /* @__PURE__ */jsxRuntime.jsxs(ui.Box, {
            overflow: "auto",
            paddingBottom: 2,
            paddingX: 2,
            children: [/* @__PURE__ */jsxRuntime.jsxs(Table, {
              children: [/* @__PURE__ */jsxRuntime.jsx("thead", {
                children: /* @__PURE__ */jsxRuntime.jsxs("tr", {
                  children: [/* @__PURE__ */jsxRuntime.jsx("th", {
                    children: /* @__PURE__ */jsxRuntime.jsx(ui.Label, {
                      muted: true,
                      size: 0,
                      style: {
                        minWidth: "5rem"
                      },
                      children: "Project ID"
                    })
                  }), /* @__PURE__ */jsxRuntime.jsx("th", {
                    children: /* @__PURE__ */jsxRuntime.jsx(ui.Label, {
                      muted: true,
                      size: 0,
                      children: "Dataset"
                    })
                  }), /* @__PURE__ */jsxRuntime.jsx("th", {
                    children: /* @__PURE__ */jsxRuntime.jsx(ui.Label, {
                      muted: true,
                      size: 0,
                      children: "Document ID"
                    })
                  })]
                })
              }), /* @__PURE__ */jsxRuntime.jsx("tbody", {
                children: crossDatasetReferences.references.filter(reference => {
                  return "projectId" in reference;
                }).map((_ref12, index) => {
                  let {
                    projectId,
                    datasetName,
                    documentId
                  } = _ref12;
                  return (
                    // eslint-disable-next-line react/no-array-index-key
                    /* @__PURE__ */
                    jsxRuntime.jsxs("tr", {
                      children: [/* @__PURE__ */jsxRuntime.jsx("td", {
                        children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                          size: 1,
                          children: projectId
                        })
                      }), /* @__PURE__ */jsxRuntime.jsx("td", {
                        children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                          size: 1,
                          children: datasetName || "unavailable"
                        })
                      }), /* @__PURE__ */jsxRuntime.jsx("td", {
                        children: /* @__PURE__ */jsxRuntime.jsxs(DocumentIdFlex, {
                          align: "center",
                          gap: 2,
                          justify: "flex-end",
                          children: [/* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                            textOverflow: "ellipsis",
                            size: 1,
                            children: documentId || "unavailable"
                          }), documentId && /* @__PURE__ */jsxRuntime.jsx(CopyToClipboard__default.default, {
                            text: documentId,
                            onCopy: () => {
                              toast.push({
                                title: "Copied document ID to clipboard!",
                                status: "success"
                              });
                            },
                            children: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
                              title: "Copy ID to clipboard",
                              mode: "bleed",
                              icon: icons.CopyIcon,
                              fontSize: 0
                            })
                          })]
                        })
                      })]
                    }, "".concat(documentId, "-").concat(index))
                  );
                })
              })]
            }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
              padding: 2,
              children: /* @__PURE__ */jsxRuntime.jsx(OtherReferenceCount, {
                ...crossDatasetReferences
              })
            })]
          })]
        })]
      })
    }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      flex: "none",
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
        children: ["If you ", action, " this document, documents that refer to it will no longer be able to access it."]
      })
    })]
  });
}
var __freeze$c = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$r(cooked, "raw", {
  value: __freeze$c(raw || cooked.slice())
}));
var _a$c, _b$4;
const DialogBody = styled__default.default(ui.Box).attrs({
  padding: 4
})(_a$c || (_a$c = __template$c(["\n  box-sizing: border-box;\n"])));
const LoadingContainer = styled__default.default(ui.Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})(_b$4 || (_b$4 = __template$c(["\n  height: 300px;\n"])));
function ConfirmDeleteDialog(_ref13) {
  let {
    id,
    type,
    action = "delete",
    onCancel,
    onConfirm
  } = _ref13;
  const dialogId = "deletion-confirmation-".concat(React.useId());
  const {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id);
  const capitalizedAction = "".concat(action.substring(0, 1).toUpperCase()).concat(action.substring(1));
  const documentTitle = /* @__PURE__ */jsxRuntime.jsx(DocTitle, {
    document: React.useMemo(() => ({
      _id: id,
      _type: type
    }), [id, type])
  });
  const showConfirmButton = !isLoading;
  return /* @__PURE__ */jsxRuntime.jsx(ui.Dialog, {
    width: 1,
    id: dialogId,
    header: "".concat(capitalizedAction, " document?"),
    footer: /* @__PURE__ */jsxRuntime.jsxs(ui.Grid, {
      columns: showConfirmButton ? 2 : 1,
      gap: 2,
      paddingX: 4,
      paddingY: 3,
      children: [/* @__PURE__ */jsxRuntime.jsx(ui.Button, {
        mode: "ghost",
        onClick: onCancel,
        text: "Cancel"
      }), showConfirmButton && /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
        "data-testid": "confirm-delete-button",
        text: totalCount > 0 ? "".concat(capitalizedAction, " anyway") : "".concat(capitalizedAction, " now"),
        tone: "critical",
        onClick: onConfirm
      })]
    }),
    onClose: onCancel,
    onClickOutside: onCancel,
    children: /* @__PURE__ */jsxRuntime.jsx(DialogBody, {
      children: crossDatasetReferences && internalReferences && !isLoading ? /* @__PURE__ */jsxRuntime.jsx(ConfirmDeleteDialogBody, {
        crossDatasetReferences,
        internalReferences,
        documentTitle,
        isLoading,
        totalCount,
        action,
        projectIds,
        datasetNames,
        hasUnknownDatasetNames,
        onReferenceLinkClick: onCancel
      }) : /* @__PURE__ */jsxRuntime.jsxs(LoadingContainer, {
        "data-testid": "loading-container",
        children: [/* @__PURE__ */jsxRuntime.jsx(ui.Spinner, {
          muted: true
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          marginTop: 3,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            align: "center",
            muted: true,
            size: 1,
            children: "Looking for referring documents\u2026"
          })
        })]
      })
    })
  });
}
function ConfirmDeleteDialogContainer(props) {
  const id = React.useId();
  const [error, setError] = React.useState(null);
  const handleRetry = React.useCallback(() => setError(null), []);
  return error ? /* @__PURE__ */jsxRuntime.jsx(ui.Dialog, {
    id: "dialog-error-".concat(id),
    "data-testid": "confirm-delete-error-dialog",
    header: "Error",
    footer: /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
      paddingX: 4,
      paddingY: 3,
      direction: "column",
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
        mode: "ghost",
        text: "Retry",
        onClick: handleRetry
      })
    }),
    onClose: props.onCancel,
    children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      padding: 4,
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        children: "An error occurred while loading referencing documents."
      })
    })
  }) : /* @__PURE__ */jsxRuntime.jsx(ui.ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsxRuntime.jsx(ConfirmDeleteDialog, {
      ...props
    })
  });
}
const MENU_GROUP_POPOVER_PROPS = {
  constrainSize: true,
  placement: "left-start",
  portal: true
};
function PaneMenuButtonItem(props) {
  const {
    disabled,
    isAfterGroup,
    node
  } = props;
  if (node.type === "divider") {
    return /* @__PURE__ */jsxRuntime.jsx(ui.MenuDivider, {});
  }
  if (node.type === "group") {
    if (node.children.length === 0) {
      return null;
    }
    if (node.expanded) {
      return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [isAfterGroup && /* @__PURE__ */jsxRuntime.jsx(ui.MenuDivider, {}), node.title && /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          padding: 2,
          paddingBottom: 1,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Label, {
            muted: true,
            size: 0,
            children: node.title
          })
        }), node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */jsxRuntime.jsx(PaneMenuButtonItem, {
            disabled: disabled || Boolean(node.disabled),
            isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
            node: child
          }, child.key);
        })]
      });
    }
    return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: [isAfterGroup && /* @__PURE__ */jsxRuntime.jsx(ui.MenuDivider, {}), /* @__PURE__ */jsxRuntime.jsx(ui.MenuGroup, {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: node.title,
        children: node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */jsxRuntime.jsx(PaneMenuButtonItem, {
            disabled: disabled || Boolean(node.disabled),
            isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
            node: child
          }, child.key);
        })
      })]
    });
  }
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [isAfterGroup && /* @__PURE__ */jsxRuntime.jsx(ui.MenuDivider, {}), /* @__PURE__ */jsxRuntime.jsx(PaneContextMenuItemResolver, {
      disabled,
      node
    })]
  });
}
function PaneContextMenuItemResolver(props) {
  const {
    node
  } = props;
  if (node.intent) {
    return /* @__PURE__ */jsxRuntime.jsx(PaneContextIntentMenuItem, {
      ...props,
      intent: node.intent
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(PaneContextMenuItem, {
    ...props
  });
}
function PaneContextMenuItem(props) {
  var _a;
  const {
    disabled,
    node
  } = props;
  const tooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
    size: 1,
    children: node.disabled.reason
  });
  return /* @__PURE__ */jsxRuntime.jsx(sanity.TooltipOfDisabled, {
    content: tooltipContent,
    placement: "left",
    children: /* @__PURE__ */jsxRuntime.jsx(ui.MenuItem, {
      disabled: disabled || Boolean(node.disabled),
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && icons.CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: node.title,
      tone: node.tone
    })
  });
}
function PaneContextIntentMenuItem(props) {
  var _a;
  const {
    disabled,
    intent,
    node
  } = props;
  const tooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
    size: 1,
    children: node.disabled.reason
  });
  const intentLink = router$1.useIntentLink({
    intent: intent.type,
    params: intent.params
  });
  const handleClick = React.useCallback(event => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  return /* @__PURE__ */jsxRuntime.jsx(sanity.TooltipOfDisabled, {
    content: tooltipContent,
    placement: "left",
    children: /* @__PURE__ */jsxRuntime.jsx(ui.MenuItem, {
      as: "a",
      disabled: disabled || Boolean(node.disabled),
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? icons.CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: node.title,
      tone: node.tone
    })
  });
}
const CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
function nodesHasTone(nodes, tone) {
  return nodes.some(node => {
    return node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone);
  });
}
function PaneContextMenuButton(props) {
  const {
    nodes
  } = props;
  const id = React.useId();
  const hasCritical = nodesHasTone(nodes, "critical");
  const hasCaution = nodesHasTone(nodes, "caution");
  return /* @__PURE__ */jsxRuntime.jsx(ui.MenuButton, {
    button: /* @__PURE__ */jsxRuntime.jsx(sanity.StatusButton, {
      icon: icons.EllipsisVerticalIcon,
      mode: "bleed",
      title: "Show menu",
      tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0
    }),
    id,
    menu: /* @__PURE__ */jsxRuntime.jsx(ui.Menu, {
      children: nodes.map((node, nodeIndex) => {
        var _a;
        const isAfterGroup = ((_a = nodes[nodeIndex - 1]) == null ? void 0 : _a.type) === "group";
        return /* @__PURE__ */jsxRuntime.jsx(PaneMenuButtonItem, {
          isAfterGroup,
          node
        }, node.key);
      })
    }),
    popover: CONTEXT_MENU_POPOVER_PROPS
  });
}
const PANE_DEBUG = false;
const PANE_COLLAPSED_WIDTH = 51;
const PANE_DEFAULT_MIN_WIDTH = PANE_COLLAPSED_WIDTH * 4;
const PaneContext = React.createContext(null);
var __freeze$b = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$q(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b;
const Root$b = styled__default.default(ui.Layer)(_a$b || (_a$b = __template$b(["\n  position: relative;\n  width: 1px;\n  min-width: 1px;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: var(--card-border-color);\n  }\n\n  &:not([data-disabled]) {\n    cursor: ew-resize;\n    width: 9px;\n    min-width: 9px;\n    margin: 0 -4px;\n\n    &:before {\n      left: 4px;\n    }\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    &[data-dragging]:after,\n    &:hover:after {\n      opacity: 0.2;\n    }\n  }\n"])));
function PaneDivider(_ref14) {
  let {
    disabled,
    element
  } = _ref14;
  const {
    resize
  } = usePaneLayout();
  const [dragging, setDragging] = React.useState(false);
  const handleMouseDown = React.useCallback(event => {
    if (!element) return;
    setDragging(true);
    event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = e => {
      e.preventDefault();
      const deltaX = e.pageX - startX;
      resize("move", element, deltaX);
    };
    const handleMouseUp = e => {
      e.preventDefault();
      setDragging(false);
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [element, resize]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$b, {
    "data-disabled": disabled ? "" : void 0,
    "data-dragging": dragging ? "" : void 0,
    onMouseDown: handleMouseDown
  });
}
var __freeze$a = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$p(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a;
const Root$a = styled__default.default(ui.Card)(_a$a || (_a$a = __template$a(["\n  outline: none;\n\n  // NOTE: This will render a border to the right side of each pane\n  // without taking up physical space.\n  box-shadow: 1px 0 0 var(--card-border-color);\n"])));
const Pane = React.forwardRef(function Pane2(props, ref) {
  var _a2, _b, _c;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = false,
    ...restProps
  } = props;
  const [rootElement, setRootElement] = React.useState(null);
  const {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout();
  const pane = panes.find(p => p.element === rootElement);
  const paneIndex = pane && panes.indexOf(pane);
  const nextPane = typeof paneIndex === "number" ? panes[paneIndex + 1] : void 0;
  const isLast = paneIndex === panes.length - 1;
  const collapsed = layoutCollapsed ? false : (pane == null ? void 0 : pane.collapsed) || false;
  const nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || false;
  const forwardedRef = ui.useForwardedRef(ref);
  const flex = (_a2 = pane == null ? void 0 : pane.flex) != null ? _a2 : flexProp;
  const currentMinWidth = (_b = pane == null ? void 0 : pane.currentMinWidth) != null ? _b : currentMinWidthProp;
  const currentMaxWidth = (_c = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c : currentMaxWidthProp;
  const setRef = React.useCallback(refValue => {
    setRootElement(refValue);
    forwardedRef.current = refValue;
  }, [forwardedRef]);
  React.useEffect(() => {
    if (!rootElement) return void 0;
    return mount(rootElement, {
      currentMinWidth: currentMinWidthProp,
      currentMaxWidth: currentMaxWidthProp,
      flex: flexProp,
      id,
      minWidth: minWidthProp,
      maxWidth: maxWidthProp
    });
  }, [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement]);
  const handleCollapse = React.useCallback(() => {
    if (!rootElement) return;
    collapse(rootElement);
  }, [collapse, rootElement]);
  const handleExpand = React.useCallback(() => {
    if (!rootElement) return;
    expand(rootElement);
  }, [expand, rootElement]);
  const contextValue = React.useMemo(() => ({
    collapse: handleCollapse,
    collapsed: layoutCollapsed ? false : collapsed,
    expand: handleExpand,
    index: paneIndex,
    isLast,
    rootElement
  }), [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]);
  const minWidth = React.useMemo(() => {
    if (layoutCollapsed) {
      return void 0;
    }
    if (collapsed) return PANE_COLLAPSED_WIDTH;
    if (currentMinWidth === 0) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    if (isLast) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    return currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]);
  const maxWidth = React.useMemo(() => {
    if (collapsed) return PANE_COLLAPSED_WIDTH;
    if (layoutCollapsed && isLast) {
      return void 0;
    }
    if (isLast) {
      if (maxWidthProp) {
        return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
      }
      return void 0;
    }
    return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]);
  const hidden = layoutCollapsed && !isLast;
  const divider = React.useMemo(() => !isLast && !layoutCollapsed && /* @__PURE__ */jsxRuntime.jsx(sanity.LegacyLayerProvider, {
    zOffset: "paneResizer",
    children: /* @__PURE__ */jsxRuntime.jsx(PaneDivider, {
      disabled: collapsed || nextCollapsed,
      element: rootElement
    })
  }), [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]);
  const style = React.useMemo(() => ({
    flex,
    minWidth,
    maxWidth: maxWidth === Infinity ? void 0 : maxWidth
  }), [flex, minWidth, maxWidth]);
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/* @__PURE__ */jsxRuntime.jsx(sanity.LegacyLayerProvider, {
      zOffset: "pane",
      children: /* @__PURE__ */jsxRuntime.jsx(PaneContext.Provider, {
        value: contextValue,
        children: /* @__PURE__ */jsxRuntime.jsxs(Root$a, {
          "data-testid": "pane",
          "data-ui": "Pane",
          tone: "inherit",
          hidden,
          id,
          overflow: layoutCollapsed ? void 0 : "hidden",
          ...restProps,
          "data-pane-collapsed": collapsed ? "" : void 0,
          "data-pane-index": paneIndex,
          "data-pane-selected": selected ? "" : void 0,
          ref: setRef,
          style,
          children: [PANE_DEBUG, /* @__PURE__ */jsxRuntime.jsx(ui.BoundaryElementProvider, {
            element: rootElement,
            children: !hidden && /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
              direction: "column",
              height: "fill",
              children
            })
          })]
        })
      })
    }), divider]
  });
});
function usePane() {
  const pane = React.useContext(PaneContext);
  if (!pane) {
    throw new Error("Pane: missing context value");
  }
  return pane;
}
var __freeze$9 = Object.freeze;
var __defProp$o = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$o(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
const Root$9 = styled__default.default(ui.Card)(_a$9 || (_a$9 = __template$9(["\n  position: relative;\n  outline: none;\n"])));
Root$9.displayName = "PaneContent__root";
const PaneContent = React.forwardRef(function PaneContent2(props, ref) {
  const {
    as,
    children,
    overflow,
    padding,
    ...restProps
  } = props;
  const {
    collapsed
  } = usePane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  return /* @__PURE__ */jsxRuntime.jsx(Root$9, {
    "data-testid": "pane-content",
    forwardedAs: as,
    ...restProps,
    flex: 1,
    hidden: collapsed,
    overflow: layoutCollapsed ? void 0 : overflow,
    padding,
    ref,
    tone: "inherit",
    children
  });
});
var __freeze$8 = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$n(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8, _b$3;
const Root$8 = styled__default.default(ui.Layer)(_a$8 || (_a$8 = __template$8(["\n  position: sticky;\n  bottom: 0;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: -1px;\n    border-bottom: 1px solid var(--card-shadow-outline-color);\n  }\n"])));
const RootCard = styled__default.default(ui.Card)(_b$3 || (_b$3 = __template$8(["\n  padding-bottom: env(safe-area-inset-bottom);\n"])));
const PaneFooter = React.forwardRef(function PaneFooter2(props, ref) {
  const {
    children,
    padding
  } = props;
  const {
    collapsed
  } = usePane();
  return /* @__PURE__ */jsxRuntime.jsx(sanity.LegacyLayerProvider, {
    zOffset: "paneFooter",
    children: /* @__PURE__ */jsxRuntime.jsx(Root$8, {
      "data-testid": "pane-footer",
      hidden: collapsed,
      ref,
      children: /* @__PURE__ */jsxRuntime.jsx(RootCard, {
        tone: "inherit",
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          padding,
          children
        })
      })
    })
  });
});
var __freeze$7 = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$m(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7, _b$2, _c$2, _d$2, _e$1, _f$1;
const Root$7 = styled__default.default(ui.Layer)(_a$7 || (_a$7 = __template$7(["\n  line-height: 0;\n  position: sticky;\n  top: 0;\n\n  &:not([data-collapsed]):after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-shadow-outline-color);\n  }\n"])));
const Layout = styled__default.default(ui.Flex)(_b$2 || (_b$2 = __template$7(["\n  transform-origin: calc(51px / 2);\n\n  [data-collapsed] > div > & {\n    transform: rotate(90deg);\n  }\n"])));
const TitleCard = styled__default.default(ui.Card)(_ref15 => {
  let {
    theme
  } = _ref15;
  const {
    fg,
    bg
  } = theme.sanity.color.card.enabled;
  return styled.css(_c$2 || (_c$2 = __template$7(["\n    background-color: ", ";\n\n    [data-ui='Text'] {\n      color: ", ";\n    }\n  "])), bg, fg);
});
const TitleTextSkeleton = styled__default.default(ui.TextSkeleton)(_d$2 || (_d$2 = __template$7(["\n  width: 66%;\n  max-width: 175px;\n"])));
const TitleText = styled__default.default(ui.Text)(_e$1 || (_e$1 = __template$7(["\n  cursor: default;\n  outline: none;\n"])));
const TabsBox = styled__default.default(ui.Box)(_ref16 => {
  let {
    theme
  } = _ref16;
  const {
    color,
    space
  } = theme.sanity;
  return styled.css(_f$1 || (_f$1 = __template$7(["\n    overflow: hidden;\n    overflow: clip;\n    position: relative;\n\n    & > div {\n      white-space: nowrap;\n      overflow: auto;\n      /* Hide scrollbars */\n      scrollbar-width: none;\n      &::-webkit-scrollbar {\n        width: 0;\n        height: 0;\n      }\n    }\n\n    /* right padding */\n    & > div:after {\n      content: '';\n      display: inline-block;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      width: ", "px;\n      height: 1px;\n    }\n\n    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      background: linear-gradient(to right, ", ", var(--card-bg-color));\n      width: ", "px;\n      pointer-events: none;\n    }\n  "])), space[3], ui.rgba(color.base.bg, 0), space[3]);
});
const PaneHeader = React.forwardRef(function PaneHeader2(props, ref) {
  const {
    actions,
    backButton,
    contentAfter,
    loading,
    subActions,
    tabs,
    tabIndex,
    title
  } = props;
  const {
    collapse,
    collapsed,
    expand,
    rootElement: paneElement
  } = usePane();
  const paneRect = ui.useElementRect(paneElement || null);
  const layoutStyle = React.useMemo(() => ({
    width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
  }), [collapsed, paneRect]);
  const handleTitleClick = React.useCallback(() => {
    if (collapsed) return;
    collapse();
  }, [collapse, collapsed]);
  const handleLayoutClick = React.useCallback(() => {
    if (!collapsed) return;
    expand();
  }, [collapsed, expand]);
  const showTabsOrSubActions = Boolean(!collapsed && (tabs || subActions));
  return /* @__PURE__ */jsxRuntime.jsx(ui.LayerProvider, {
    zOffset: 100,
    children: /* @__PURE__ */jsxRuntime.jsx(Root$7, {
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: /* @__PURE__ */jsxRuntime.jsx(sanity.LegacyLayerProvider, {
        zOffset: "paneHeader",
        children: /* @__PURE__ */jsxRuntime.jsxs(ui.Card, {
          "data-collapsed": collapsed ? "" : void 0,
          tone: "inherit",
          children: [/* @__PURE__ */jsxRuntime.jsxs(Layout, {
            onClick: handleLayoutClick,
            padding: 2,
            sizing: "border",
            style: layoutStyle,
            children: [backButton && /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
              flex: "none",
              padding: 1,
              children: backButton
            }), /* @__PURE__ */jsxRuntime.jsxs(TitleCard, {
              __unstable_focusRing: true,
              flex: 1,
              forwardedAs: "button",
              marginRight: actions ? 1 : 0,
              onClick: handleTitleClick,
              paddingLeft: backButton ? 1 : 3,
              paddingY: 3,
              tabIndex,
              children: [loading && /* @__PURE__ */jsxRuntime.jsx(TitleTextSkeleton, {
                animated: true,
                radius: 1
              }), !loading && /* @__PURE__ */jsxRuntime.jsx(TitleText, {
                textOverflow: "ellipsis",
                weight: "semibold",
                children: title
              })]
            }), actions && /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
              align: "center",
              hidden: collapsed,
              children: /* @__PURE__ */jsxRuntime.jsx(sanity.LegacyLayerProvider, {
                zOffset: "paneHeader",
                children: actions
              })
            })]
          }), showTabsOrSubActions && /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            paddingTop: 1,
            children: [/* @__PURE__ */jsxRuntime.jsx(TabsBox, {
              flex: 1,
              marginRight: subActions ? 3 : 0,
              children: tabs
            }), subActions && subActions]
          }), !collapsed && contentAfter && contentAfter]
        })
      })
    })
  });
});
function PaneHeaderActionButton(props) {
  const {
    node,
    padding
  } = props;
  if (node.type === "item") {
    return /* @__PURE__ */jsxRuntime.jsx(PaneHeaderMenuItemActionButton, {
      node,
      padding
    });
  }
  if (node.type === "group") {
    return /* @__PURE__ */jsxRuntime.jsx(PaneHeaderMenuGroupActionButton, {
      node,
      padding
    });
  }
  console.warn('unknown menu node (expected `type: "item" | "group"`):', node);
  return null;
}
function PaneHeaderMenuItemActionButton(props) {
  var _a;
  const {
    node,
    padding
  } = props;
  if (node.intent) {
    return /* @__PURE__ */jsxRuntime.jsx(PaneHeaderActionIntentButton, {
      ...props,
      intent: node.intent
    });
  }
  const disabledTooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
    size: 1,
    children: node.disabled.reason
  });
  return /* @__PURE__ */jsxRuntime.jsx(sanity.TooltipOfDisabled, {
    content: disabledTooltipContent,
    placement: "bottom",
    children: /* @__PURE__ */jsxRuntime.jsx(sanity.StatusButton, {
      disabled: Boolean(node.disabled),
      hotkey: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      label: disabledTooltipContent ? void 0 : node.title,
      onClick: node.onAction,
      padding,
      selected: node.selected,
      tone: node.tone
    })
  });
}
function PaneHeaderActionIntentButton(props) {
  var _a;
  const {
    intent,
    node,
    padding
  } = props;
  const disabledTooltipContent = typeof node.disabled === "object" && /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
    size: 1,
    children: node.disabled.reason
  });
  const intentLink = router$1.useIntentLink({
    intent: intent.type,
    params: intent.params
  });
  const handleClick = React.useCallback(event => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  return /* @__PURE__ */jsxRuntime.jsx(sanity.TooltipOfDisabled, {
    content: disabledTooltipContent,
    placement: "bottom",
    children: /* @__PURE__ */jsxRuntime.jsx(sanity.StatusButton, {
      as: "a",
      disabled: Boolean(node.disabled),
      hotkey: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      label: disabledTooltipContent ? void 0 : node.title,
      onClick: handleClick,
      padding,
      selected: node.selected,
      tone: node.tone
    })
  });
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a;
  const {
    node,
    padding
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(ui.MenuButton, {
    button: /* @__PURE__ */jsxRuntime.jsx(sanity.StatusButton, {
      disabled: node.disabled,
      icon: (_a = node.icon) != null ? _a : icons.UnknownIcon,
      label: node.title,
      padding
    }),
    id: React.useId(),
    menu: /* @__PURE__ */jsxRuntime.jsx(ui.Menu, {
      children: node.children.map((child, idx) => {
        var _a2;
        return /* @__PURE__ */jsxRuntime.jsx(PaneMenuButtonItem, {
          disabled: Boolean(node.disabled),
          isAfterGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group",
          node: child
        }, child.key);
      })
    })
  });
}
var __freeze$6 = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$l(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6;
const Root$6 = styled__default.default(ui.Card)(_a$6 || (_a$6 = __template$6(["\n  transition: opacity 200ms;\n  position: relative;\n  z-index: 1;\n  padding-left: env(safe-area-inset-left);\n  padding-right: env(safe-area-inset-right);\n  opacity: 0;\n\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  &:not([data-collapsed]) {\n    overflow: auto;\n  }\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n\n  &[data-resizing] {\n    pointer-events: none;\n  }\n"])));
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
const isNotMenuNodeButton = negate__default.default(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a, _b;
  const {
    fieldActions = [],
    menuItems,
    menuItemGroups
  } = params;
  const nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, "".concat(i, "-").concat(a.type)));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups) {
    const group = groups.find(g => g.key === itemGroup.id);
    if (!group) {
      groups.push({
        type: "group",
        key: itemGroup.id,
        children: [],
        expanded: true,
        renderAsButton: false,
        title: itemGroup.title
      });
    }
  }
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find(g => g.key === item.group);
    if (item.group && !group) {
      group = {
        type: "group",
        key: item.group,
        expanded: true,
        icon: item.icon,
        title: item.group,
        children: [],
        renderAsButton: false
      };
      groups.push(group);
    }
    if (group) {
      group.children.push({
        type: "item",
        key: "".concat(keyOffset + i, "-item"),
        hotkey: item.shortcut,
        icon: item.icon,
        onAction: () => params.actionHandler(item),
        renderAsButton: (_a = item.showAsAction) != null ? _a : false,
        selected: item.selected,
        title: item.title,
        tone: item.tone
      });
    } else {
      ungroupedItems.push({
        type: "item",
        key: "".concat(keyOffset + i, "-item"),
        hotkey: item.shortcut,
        icon: item.icon,
        onAction: () => params.actionHandler(item),
        renderAsButton: (_b = item.showAsAction) != null ? _b : false,
        selected: item.selected,
        title: item.title,
        tone: item.tone
      });
    }
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a, _b, _c;
  if (a.type === "divider") {
    return {
      type: "divider",
      key
    };
  }
  if (a.type === "group") {
    return {
      type: "group",
      key,
      children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, "".concat(key, "-").concat(childIdx, "-").concat(child.type))),
      disabled: a.disabled,
      expanded: (_a = a.expanded) != null ? _a : true,
      icon: a.icon,
      title: a.title,
      renderAsButton: (_b = a.renderAsButton) != null ? _b : false
    };
  }
  return {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c = a.renderAsButton) != null ? _c : false,
    selected: a.selected,
    title: a.title,
    tone: a.tone
  };
}
const IntentButton = React.forwardRef(function IntentButton2(props, ref) {
  const {
    intent,
    ...restProps
  } = props;
  const Link = React.useMemo(() =>
  // eslint-disable-next-line @typescript-eslint/no-shadow
  React.forwardRef(function Link2(linkProps, linkRef) {
    return /* @__PURE__ */jsxRuntime.jsx(router$1.IntentLink, {
      ...linkProps,
      intent: intent.type,
      params: intent.params,
      ref: linkRef
    });
  }), [intent]);
  return props.disabled ? /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
    ...props,
    as: "a",
    role: "link",
    "aria-disabled": "true"
  }) : /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
    ...restProps,
    as: Link,
    "data-as": "a",
    ref
  });
});
function InsufficientPermissionsMessageTooltip(_ref17) {
  let {
    reveal,
    loading,
    children
  } = _ref17;
  const currentUser = sanity.useCurrentUser();
  if (!reveal) {
    return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(ui.Tooltip, {
    content: loading ? /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      padding: 2,
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        children: "Loading\u2026"
      })
    }) : /* @__PURE__ */jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, {
      currentUser
    }),
    portal: true,
    children: /* @__PURE__ */jsxRuntime.jsx("div", {
      children
    })
  });
}
const POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
const getIntent = (schema, templates, item) => {
  var _a;
  const typeName = (_a = templates.find(t => t.id === item.templateId)) == null ? void 0 : _a.schemaType;
  if (!typeName) return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton(_ref18) {
  let {
    templateItems
  } = _ref18;
  const schema = sanity.useSchema();
  const templates = sanity.useTemplates();
  const [templatePermissions, isTemplatePermissionsLoading] = sanity.useTemplatePermissions({
    templateItems
  });
  const nothingGranted = React.useMemo(() => {
    return !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every(permission => !permission.granted));
  }, [isTemplatePermissionsLoading, templatePermissions]);
  const permissionsById = React.useMemo(() => {
    if (!templatePermissions) return {};
    return templatePermissions.reduce((acc, permission) => {
      acc[permission.id] = permission;
      return acc;
    }, {});
  }, [templatePermissions]);
  if (nothingGranted) {
    return /* @__PURE__ */jsxRuntime.jsx(InsufficientPermissionsMessageTooltip, {
      reveal: true,
      loading: isTemplatePermissionsLoading,
      children: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
        "aria-label": "Insufficient permissions",
        icon: icons.ComposeIcon,
        mode: "bleed",
        disabled: true,
        "data-testid": "action-intent-button"
      })
    });
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0];
    const permissions = permissionsById[firstItem.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema, templates, firstItem);
    if (!intent) return null;
    return /* @__PURE__ */jsxRuntime.jsx(InsufficientPermissionsMessageTooltip, {
      reveal: disabled,
      loading: isTemplatePermissionsLoading,
      children: /* @__PURE__ */jsxRuntime.jsx(IntentButton, {
        "aria-label": firstItem.title,
        icon: firstItem.icon || icons.ComposeIcon,
        intent,
        mode: "bleed",
        disabled,
        "data-testid": "action-intent-button"
      })
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(ui.MenuButton, {
    button: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
      icon: icons.ComposeIcon,
      mode: "bleed",
      "data-testid": "multi-action-intent-button"
    }),
    id: "create-menu",
    menu: /* @__PURE__ */jsxRuntime.jsxs(ui.Menu, {
      children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
        paddingX: 3,
        paddingTop: 3,
        paddingBottom: 2,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Label, {
          muted: true,
          children: "Create"
        })
      }), templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id];
        const disabled = !(permissions == null ? void 0 : permissions.granted);
        const intent = getIntent(schema, templates, item);
        const template = templates.find(t => t.id === item.templateId);
        if (!template || !intent) return null;
        const Link = React.forwardRef((linkProps, linkRef) => disabled ? /* @__PURE__ */jsxRuntime.jsx("button", {
          type: "button",
          disabled: true,
          ...linkProps,
          ref: linkRef
        }) : /* @__PURE__ */jsxRuntime.jsx(router$1.IntentLink, {
          ...linkProps,
          intent: intent.type,
          params: intent.params,
          ref: linkRef
        }));
        Link.displayName = "Link";
        return /* @__PURE__ */jsxRuntime.jsx(InsufficientPermissionsMessageTooltip, {
          reveal: disabled,
          loading: isTemplatePermissionsLoading,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.MenuItem, {
            as: Link,
            "data-as": disabled ? "button" : "a",
            text: item.title || template.title,
            "aria-label": disabled ? "Insufficient permissions" : item.title || template.title,
            disabled,
            "data-testid": "action-intent-button-".concat(itemIndex)
          })
        }, item.id);
      })]
    }),
    popover: POPOVER_PROPS
  });
}
function isNonNullable(value) {
  return value !== null && value !== void 0;
}
const hashObject = value => {
  const sortObject = v => {
    if (typeof v !== "object" || !v) return v;
    if (Array.isArray(v)) return v.map(sortObject);
    return Object.entries(v).sort((_ref19, _ref20) => {
      let [keyA] = _ref19;
      let [keyB] = _ref20;
      return keyA.localeCompare(keyB, "en");
    });
  };
  const normalize = v => JSON.parse(JSON.stringify(v));
  return JSON.stringify(sortObject(normalize(value)));
};
const PaneHeaderActions = React.memo(function PaneHeaderActions2(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = sanity.EMPTY_ARRAY,
    menuItems = sanity.EMPTY_ARRAY,
    menuItemGroups = sanity.EMPTY_ARRAY,
    actionHandlers = sanity.EMPTY_OBJECT
  } = props;
  const templates = sanity.useTemplates();
  const handleAction = React.useCallback(item => {
    if (typeof item.action === "string" && !(item.action in actionHandlers)) {
      console.warn("No handler for action:", item.action);
      return false;
    }
    const handler =
    // eslint-disable-next-line no-nested-ternary
    typeof item.action === "function" ? item.action : typeof item.action === "string" ? actionHandlers[item.action] : null;
    if (handler) {
      handler(item.params);
      return true;
    }
    return false;
  }, [actionHandlers]);
  const menuNodes = React.useMemo(() => resolveMenuNodes({
    actionHandler: handleAction,
    menuItemGroups,
    menuItems: menuItems.filter(item => {
      var _a;
      return ((_a = item.intent) == null ? void 0 : _a.type) !== "create";
    })
  }), [handleAction, menuItemGroups, menuItems]);
  const actionNodes = React.useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = React.useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const initialValueTemplateItemFromMenuItems = React.useMemo(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _a;
      if (((_a = item.intent) == null ? void 0 : _a.type) !== "create") return null;
      const {
        params
      } = item.intent;
      if (!params) return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : void 0;
      const templateId = intentParams.template || intentParams.type;
      if (!templateId) return null;
      const template = templates.find(t => t.id === templateId);
      if (!template) return null;
      const initialDocumentId = intentParams.id;
      return {
        item,
        template,
        templateParams,
        menuItemIndex,
        initialDocumentId
      };
    }).filter(isNonNullable).map(_ref21 => {
      let {
        initialDocumentId,
        item,
        template,
        menuItemIndex,
        templateParams
      } = _ref21;
      const initialValueTemplateItem = {
        id: "menuItem".concat(menuItemIndex),
        initialDocumentId,
        templateId: template.id,
        type: "initialValueTemplateItem",
        title: item.title || template.title,
        icon: item.icon,
        description: template.description,
        parameters: templateParams,
        schemaType: template.schemaType
      };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = React.useMemo(() => {
    return uniqBy__default.default([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], item => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
    gap: 1,
    children: [combinedInitialValueTemplates.length > 0 && /* @__PURE__ */jsxRuntime.jsx(PaneHeaderCreateButton, {
      templateItems: combinedInitialValueTemplates
    }), actionNodes.map(node => /* @__PURE__ */jsxRuntime.jsx(PaneHeaderActionButton, {
      node
    }, node.key)), contextMenuNodes.length > 0 && /* @__PURE__ */jsxRuntime.jsx(PaneContextMenuButton, {
      nodes: contextMenuNodes
    })]
  });
});
const DocumentPaneContext = React.createContext(null);
function useDocumentPane() {
  const documentPane = React.useContext(DocumentPaneContext);
  if (!documentPane) {
    throw new Error("DocumentPane: missing context value");
  }
  return documentPane;
}
const DISABLED_REASON_TITLE$4 = {
  NOTHING_TO_DELETE: "This document doesn\u2019t yet exist or is already deleted"
};
const DeleteAction = _ref22 => {
  let {
    id,
    type,
    draft,
    onComplete
  } = _ref22;
  const {
    setIsDeleting: paneSetIsDeleting
  } = useDocumentPane();
  const {
    delete: deleteOp
  } = sanity.useDocumentOperation(id, type);
  const [isDeleting, setIsDeleting] = React.useState(false);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(false);
  const handleCancel = React.useCallback(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = React.useCallback(() => {
    setIsDeleting(true);
    setConfirmDialogOpen(false);
    paneSetIsDeleting(true);
    deleteOp.execute();
    onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]);
  const handle = React.useCallback(() => {
    setConfirmDialogOpen(true);
  }, []);
  const [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  });
  const currentUser = sanity.useCurrentUser();
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: icons.TrashIcon,
      disabled: true,
      label: "Delete",
      title: /* @__PURE__ */jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, {
        operationLabel: "delete this document",
        currentUser
      })
    };
  }
  return {
    tone: "critical",
    icon: icons.TrashIcon,
    disabled: isDeleting || Boolean(deleteOp.disabled) || isPermissionsLoading,
    title: deleteOp.disabled && DISABLED_REASON_TITLE$4[deleteOp.disabled] || "",
    label: isDeleting ? "Deleting\u2026" : "Delete",
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: /* @__PURE__ */jsxRuntime.jsx(ConfirmDeleteDialogContainer, {
        action: "delete",
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        onCancel: handleCancel,
        onConfirm: handleConfirm
      })
    }
  };
};
DeleteAction.action = "delete";
const DISABLED_REASON_TITLE$3 = {
  NO_CHANGES: "This document has no unpublished changes",
  NOT_PUBLISHED: "This document is not published"
};
const DiscardChangesAction = _ref23 => {
  let {
    id,
    type,
    published,
    liveEdit,
    onComplete
  } = _ref23;
  const {
    discardChanges
  } = sanity.useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(false);
  const [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  });
  const currentUser = sanity.useCurrentUser();
  const handleConfirm = React.useCallback(() => {
    discardChanges.execute();
    onComplete();
  }, [discardChanges, onComplete]);
  const handle = React.useCallback(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = React.useMemo(() => isConfirmDialogOpen && {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: "Are you sure you want to discard all changes since last published?"
    })
  }, [handleConfirm, isConfirmDialogOpen, onComplete]);
  if (!published || liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: icons.ResetIcon,
      disabled: true,
      label: "Discard changes",
      title: /* @__PURE__ */jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, {
        operationLabel: "discard changes in this document",
        currentUser
      })
    };
  }
  return {
    tone: "critical",
    icon: icons.ResetIcon,
    disabled: Boolean(discardChanges.disabled) || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_TITLE$3[discardChanges.disabled] || "",
    label: "Discard changes",
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
const DISABLED_REASON_TITLE$2 = {
  NOTHING_TO_DUPLICATE: "This document doesn\u2019t yet exist so there\u2018s nothing to duplicate"
};
const DuplicateAction = _ref24 => {
  let {
    id,
    type,
    onComplete
  } = _ref24;
  const {
    duplicate
  } = sanity.useDocumentOperation(id, type);
  const {
    navigateIntent
  } = router$1.useRouter();
  const [isDuplicating, setDuplicating] = React.useState(false);
  const [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  });
  const currentUser = sanity.useCurrentUser();
  const handle = React.useCallback(() => {
    const dupeId = uuid.uuid();
    setDuplicating(true);
    duplicate.execute(dupeId);
    navigateIntent("edit", {
      id: dupeId,
      type
    });
    onComplete();
  }, [duplicate, navigateIntent, onComplete, type]);
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      icon: icons.CopyIcon,
      disabled: true,
      label: "Duplicate",
      title: /* @__PURE__ */jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, {
        operationLabel: "duplicate this document",
        currentUser
      })
    };
  }
  return {
    icon: icons.CopyIcon,
    disabled: isDuplicating || Boolean(duplicate.disabled) || isPermissionsLoading,
    label: isDuplicating ? "Duplicating\u2026" : "Duplicate",
    title: duplicate.disabled && DISABLED_REASON_TITLE$2[duplicate.disabled] || "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
const HistoryRestoreAction = _ref25 => {
  let {
    id,
    type,
    revision,
    onComplete
  } = _ref25;
  const {
    restore
  } = sanity.useDocumentOperation(id, type);
  const event = sanity.useDocumentOperationEvent(id, type);
  const {
    navigateIntent
  } = router$1.useRouter();
  const prevEvent = React.useRef(event);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(false);
  const handleConfirm = React.useCallback(() => {
    restore.execute(revision);
    onComplete();
  }, [restore, revision, onComplete]);
  React.useEffect(() => {
    if (!event || event === prevEvent.current) return;
    if (event.type === "success" && event.op === "restore") {
      navigateIntent("edit", {
        id,
        type
      });
    }
    prevEvent.current = event;
  }, [event, id, navigateIntent, type]);
  const handle = React.useCallback(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = React.useMemo(() => {
    if (isConfirmDialogOpen) {
      return {
        type: "confirm",
        tone: "critical",
        onCancel: onComplete,
        onConfirm: handleConfirm,
        message: /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
          children: "Are you sure you want to restore this document?"
        })
      };
    }
    return null;
  }, [handleConfirm, isConfirmDialogOpen, onComplete]);
  const isRevisionInitialVersion = revision === "@initial";
  const isRevisionLatestVersion = revision === void 0;
  if (isRevisionLatestVersion) {
    return null;
  }
  return {
    label: "Restore",
    color: "primary",
    onHandle: handle,
    title: isRevisionInitialVersion ? "You can't restore to the initial version" : "Restore to this version",
    icon: icons.RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
const DISABLED_REASON_TITLE$1 = {
  LIVE_EDIT_ENABLED: "Cannot publish since liveEdit is enabled for this document type",
  ALREADY_PUBLISHED: "Already published",
  NO_CHANGES: "No unpublished changes",
  NOT_READY: "Operation not ready"
};
function getDisabledReason(reason, publishedAt) {
  if (reason === "ALREADY_PUBLISHED" && publishedAt) {
    return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: /* @__PURE__ */jsxRuntime.jsxs("span", {
        children: ["Published ", /* @__PURE__ */jsxRuntime.jsx(TimeAgo, {
          time: publishedAt
        })]
      })
    });
  }
  return DISABLED_REASON_TITLE$1[reason];
}
const PublishAction = props => {
  var _a;
  const {
    id,
    type,
    liveEdit,
    draft,
    published
  } = props;
  const [publishState, setPublishState] = React.useState(null);
  const {
    publish
  } = sanity.useDocumentOperation(id, type);
  const validationStatus = sanity.useValidationStatus(id, type);
  const syncState = sanity.useSyncState(id, type);
  const {
    changesOpen,
    onHistoryOpen,
    documentId,
    documentType
  } = useDocumentPane();
  const editState = sanity.useEditState(documentId, documentType);
  const revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev;
  const hasValidationErrors = validationStatus.validation.some(types.isValidationErrorMarker);
  const [publishScheduled, setPublishScheduled] = React.useState(false);
  const isSyncing = syncState.isSyncing;
  const isValidating = validationStatus.isValidating;
  const [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  });
  const currentUser = sanity.useCurrentUser();
  const title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt) || "" : hasValidationErrors ? "There are validation errors that need to be fixed before this document can be published" : "";
  const hasDraft = Boolean(draft);
  const doPublish = React.useCallback(() => {
    publish.execute();
    setPublishState("publishing");
  }, [publish]);
  React.useEffect(() => {
    const validationComplete = validationStatus.isValidating === false && validationStatus.revision !== revision;
    if (!publishScheduled || isSyncing || !validationComplete) {
      return;
    }
    if (!hasValidationErrors) {
      doPublish();
    }
    setPublishScheduled(false);
  }, [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating]);
  React.useEffect(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    if (didPublish) {
      if (changesOpen) {
        onHistoryOpen();
      }
    }
    const nextState = didPublish ? "published" : null;
    const delay = didPublish ? 200 : 4e3;
    const timer = setTimeout(() => {
      setPublishState(nextState);
    }, delay);
    return () => clearTimeout(timer);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const handle = React.useCallback(() => {
    if (syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision) {
      setPublishScheduled(true);
    } else {
      doPublish();
    }
  }, [syncState.isSyncing, validationStatus.isValidating, validationStatus.revision, revision, doPublish]);
  if (liveEdit) {
    return {
      tone: "positive",
      label: "Publish",
      title: "Live Edit is enabled for this content type and publishing happens automatically as you make changes",
      disabled: true
    };
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "positive",
      label: "Publish",
      title: /* @__PURE__ */jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, {
        operationLabel: "publish this document",
        currentUser
      }),
      disabled: true
    };
  }
  const disabled = Boolean(publishScheduled || ((_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled) || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "positive",
    label:
    // eslint-disable-next-line no-nested-ternary
    publishState === "published" ? "Published" : publishScheduled || publishState === "publishing" ? "Publishing\u2026" : "Publish",
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: publishState === "published" ? icons.CheckmarkIcon : icons.PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? "Waiting for tasks to finish before publishing" : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
const DISABLED_REASON_TITLE = {
  NOT_PUBLISHED: "This document is not published"
};
const UnpublishAction = _ref26 => {
  let {
    id,
    type,
    draft,
    onComplete,
    liveEdit
  } = _ref26;
  const {
    unpublish
  } = sanity.useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(false);
  const [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  });
  const currentUser = sanity.useCurrentUser();
  const handleCancel = React.useCallback(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = React.useCallback(() => {
    setConfirmDialogOpen(false);
    unpublish.execute();
    onComplete();
  }, [onComplete, unpublish]);
  const dialog = React.useMemo(() => {
    if (isConfirmDialogOpen) {
      return {
        type: "dialog",
        onClose: onComplete,
        content: /* @__PURE__ */jsxRuntime.jsx(ConfirmDeleteDialogContainer, {
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          action: "unpublish",
          onCancel: handleCancel,
          onConfirm: handleConfirm
        })
      };
    }
    return null;
  }, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  if (liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return {
      tone: "critical",
      icon: icons.UnpublishIcon,
      label: "Unpublish",
      title: /* @__PURE__ */jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, {
        operationLabel: "unpublish this document",
        currentUser
      }),
      disabled: true
    };
  }
  return {
    tone: "critical",
    icon: icons.UnpublishIcon,
    disabled: Boolean(unpublish.disabled) || isPermissionsLoading,
    label: "Unpublish",
    title: unpublish.disabled ? DISABLED_REASON_TITLE[unpublish.disabled] : "",
    onHandle: () => setConfirmDialogOpen(true),
    dialog
  };
};
UnpublishAction.action = "unpublish";
const LiveEditBadge = props => {
  const {
    liveEdit
  } = props;
  if (liveEdit) {
    return {
      label: "Live",
      color: "danger"
    };
  }
  return null;
};
const _DEBUG = false;
const EMPTY_PARAMS$2 = {};
const LOADING_PANE = Symbol("LOADING_PANE");
const DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
const state = {
  activePanes: []
};
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a;
  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || uuid.uuid();
  const isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object") continue;
    if (((_a = pane.canHandleIntent) == null ? void 0 : _a.call(pane, intent, params, {
      pane,
      index: i
    })) ||
    // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? {
        template: params.template
      } : EMPTY_PARAMS$2;
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }
  return {
    intent,
    params,
    payload
  };
}
const EMPTY_PARAMS$1 = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map(group => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
const router = router$1.route.create("/", [
// "Asynchronous intent resolving" route
router$1.route.intents("/intent"),
// Legacy fallback route, will be redirected to new format
router$1.route.create("/edit/:type/:editDocumentId", [router$1.route.create({
  path: "/:params",
  transform: {
    params: {
      toState: legacyEditParamsToState,
      toPath: legacyEditParamsToPath
    }
  }
})]),
// The regular path - when the intent can be resolved to a specific pane
router$1.route.create({
  path: "/:panes",
  // Legacy URLs, used to handle redirects
  children: [router$1.route.create("/:action", router$1.route.create("/:legacyEditDocumentId"))],
  transform: {
    panes: {
      toState,
      toPath
    }
  }
})]);
const panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
const isParam = str => /^[a-z0-9]+=[^=]+/i.test(str);
const isPayload = str => /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
const exclusiveParams = ["view", "since", "rev", "inspect"];
const isTruthy = Boolean;
function parseChunks(chunks, initial) {
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = {
        ...pane.params,
        [decodeURIComponent(key)]: decodeURIComponent(value)
      };
    } else if (isPayload(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }
    return pane;
  }, {
    ...initial,
    params: EMPTY_PARAMS$1,
    payload: void 0
  });
}
function encodeChunks(pane, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : btoa(JSON.stringify(payload));
  const encodedParams = Object.entries(params).filter(entry => {
    var _a;
    const [key, value] = entry;
    if (!value) return false;
    if (paneIsFirstSibling) return true;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key)) return false;
    return true;
  }).map(_ref27 => {
    let [key, value] = _ref27;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }
  return str.split(";").map(group => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map(segment => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map(sibling => ({
      ...firstSibling,
      ...sibling,
      id: sibling.id || firstSibling.id,
      params: {
        ...omit__default.default(firstSibling.params, exclusiveParams),
        ...sibling.params
      },
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter(group => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    });
    buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}
function tryParseBase64Payload(data) {
  return data ? tryParsePayload(atob(data)) : void 0;
}
const DOCUMENT_PANEL_MIN_WIDTH = 320;
const DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
const DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
const DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
const EMPTY_PARAMS = {};
const INSPECT_ACTION_PREFIX = "inspect:";
const DEFAULT_MENU_ITEM_GROUPS = [{
  id: "inspectors"
}, {
  id: "links"
}];
const HISTORY_INSPECTOR_NAME = "sanity/desk/history";
const VALIDATION_INSPECTOR_NAME = "sanity/desk/validation";
const Root$5 = styled__default.default(ui.Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0,
  "&:after": {
    content: '""',
    display: "block",
    position: "absolute",
    left: 0,
    bottom: -1,
    right: 0,
    borderBottom: "1px solid var(--card-border-color)",
    opacity: 0.5
  }
});
function DocumentInspectorHeader(props) {
  const {
    as: forwardedAs,
    children,
    closeButtonLabel,
    onClose,
    title,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsxs(Root$5, {
    ...restProps,
    as: forwardedAs,
    children: [/* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
      padding: 2,
      children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
        flex: 1,
        padding: 3,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          as: "h1",
          size: 1,
          weight: "semibold",
          children: title
        })
      }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
        flex: "none",
        padding: 1,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
          "aria-label": closeButtonLabel,
          fontSize: 1,
          icon: icons.CloseIcon,
          mode: "bleed",
          onClick: onClose,
          padding: 2
        })
      })]
    }), children]
  });
}
const DeskToolContext = React.createContext(null);
function useDeskTool() {
  const deskTool = React.useContext(DeskToolContext);
  if (!deskTool) throw new Error("DeskTool: missing context value");
  return deskTool;
}
var __freeze$5 = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$k(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
const Root$4 = styled__default.default.div(_a$5 || (_a$5 = __template$5(["\n  position: absolute;\n  top: 0;\n  left: -4px;\n  bottom: 0;\n  width: 9px;\n  z-index: 201;\n  cursor: ew-resize;\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n    opacity: 0.5;\n  }\n\n  /* Hover effect */\n  & > span:nth-child(2) {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 9px;\n    bottom: 0;\n    background-color: var(--card-border-color);\n    opacity: 0;\n    transition: opacity 150ms;\n  }\n\n  @media (hover: hover) {\n    &:hover > span:nth-child(2) {\n      opacity: 0.2;\n    }\n  }\n"])));
function Resizer(props) {
  const {
    onResize,
    onResizeStart
  } = props;
  const mouseXRef = React.useRef(0);
  const handleMouseDown = React.useCallback(event => {
    event.preventDefault();
    mouseXRef.current = event.pageX;
    onResizeStart();
    const handleMouseMove = e => {
      e.preventDefault();
      onResize(e.pageX - mouseXRef.current);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [onResize, onResizeStart]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$4, {
    onMouseDown: handleMouseDown,
    children: [/* @__PURE__ */jsxRuntime.jsx("span", {}), /* @__PURE__ */jsxRuntime.jsx("span", {})]
  });
}
var __freeze$4 = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$j(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
const Root$3 = styled__default.default(ui.Box)(_a$4 || (_a$4 = __template$4(["\n  position: relative;\n  flex: 1;\n  padding-left: 1px;\n"])));
function Resizable(props) {
  const {
    as: forwardedAs,
    children,
    minWidth,
    maxWidth,
    ...restProps
  } = props;
  const [element, setElement] = React.useState(null);
  const elementWidthRef = React.useRef();
  const [targetWidth, setTargetWidth] = React.useState();
  const handleResizeStart = React.useCallback(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]);
  const handleResize = React.useCallback(deltaX => {
    const w = elementWidthRef.current;
    if (!w) return;
    setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
  }, [minWidth, maxWidth]);
  const style = React.useMemo(() => targetWidth ? {
    flex: "none",
    width: targetWidth
  } : {
    minWidth,
    maxWidth
  }, [minWidth, maxWidth, targetWidth]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$3, {
    as: forwardedAs,
    ...restProps,
    ref: setElement,
    style,
    children: [children, /* @__PURE__ */jsxRuntime.jsx(Resizer, {
      onResize: handleResize,
      onResizeStart: handleResizeStart
    })]
  });
}
function getPathTypes(options) {
  const {
    path,
    schemaType,
    value
  } = options;
  const result = [];
  let s = schemaType;
  let v = value;
  for (const segment of path) {
    if (typeof segment === "string") {
      if (!sanity.isRecord(v) && v !== void 0) {
        throw new Error("Parent value is not an object, cannot get path segment: .".concat(segment));
      }
      if (s.jsonType !== "object") {
        throw new Error("Parent type is not an object schema type, cannot get path segment: .".concat(segment));
      }
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find(f => f.name === segment);
      if (!field) {
        throw new Error("Field type not found: .".concat(segment));
      }
      s = field.type;
      result.push(s);
      continue;
    }
    if (typeof segment === "number") {
      if (!sanity.isArray(v) && v !== void 0) {
        throw new Error("Parent value is not an array, cannot get path segment: [".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: [".concat(segment, "]"));
      }
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find(ofType => {
        if (typeof v === "string") {
          return ofType.jsonType === "string";
        }
        if (typeof v === "number") {
          return ofType.jsonType === "number";
        }
        if (typeof v === "boolean") {
          return ofType.jsonType === "boolean";
        }
        if (sanity.isRecord(v)) {
          return ofType.name === (v == null ? void 0 : v._type);
        }
        return false;
      });
      if (!itemType) {
        throw new Error("Item type not found: [".concat(segment, "]"));
      }
      s = itemType;
      result.push(s);
      continue;
    }
    if (sanity.isRecord(segment) && segment._key) {
      if (!sanity.isArray(v)) {
        throw new Error("Parent value is not an array, cannot get path segment: [_key == ".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: .".concat(segment));
      }
      const values = v != null ? v : [];
      v = values.find(i => sanity.isRecord(i) && i._key === segment._key);
      if (!sanity.isRecord(v)) {
        throw new Error("Array item not found: [_key == ".concat(segment._key, "]"));
      }
      const ofType = s.of.find(i => sanity.isRecord(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType) {
        throw new Error("Array item type not found: .".concat(v == null ? void 0 : v._type));
      }
      s = ofType;
      result.push(s);
      continue;
    }
    throw new Error("Invalid path segment: ".concat(JSON.stringify(segment)));
  }
  return result;
}
const MARKER_ICON = {
  error: icons.ErrorOutlineIcon,
  warning: icons.WarningOutlineIcon,
  info: icons.InfoOutlineIcon
};
const MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const {
    onClose
  } = props;
  const {
    onFocus,
    onPathOpen,
    schemaType,
    validation,
    value
  } = useDocumentPane();
  const handleOpen = React.useCallback(path => {
    onPathOpen(path);
    onFocus(path);
  }, [onFocus, onPathOpen]);
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
    direction: "column",
    height: "fill",
    overflow: "hidden",
    children: [/* @__PURE__ */jsxRuntime.jsx(DocumentInspectorHeader, {
      as: "header",
      closeButtonLabel: "Close validation",
      flex: "none",
      onClose,
      title: "Validation"
    }), /* @__PURE__ */jsxRuntime.jsxs(ui.Card, {
      flex: 1,
      overflow: "auto",
      padding: 3,
      children: [validation.length === 0 && /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
        padding: 2,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          muted: true,
          size: 1,
          children: "No validation errors"
        })
      }), validation.length > 0 && /* @__PURE__ */jsxRuntime.jsx(ui.Stack, {
        space: 2,
        children: validation.map((marker, i) => /* @__PURE__ */jsxRuntime.jsx(ValidationCard, {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        }, i))
      })]
    })]
  });
}
function ValidationCard(props) {
  const {
    marker,
    onOpen,
    schemaType,
    value
  } = props;
  const handleOpen = React.useCallback(() => onOpen(marker.path), [marker, onOpen]);
  const [errorInfo, setErrorInfo] = React.useState(null);
  return /* @__PURE__ */jsxRuntime.jsxs(ui.ErrorBoundary, {
    onCatch: setErrorInfo,
    children: [errorInfo && /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
      padding: 3,
      radius: 2,
      tone: "critical",
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
        size: 1,
        children: ["ERROR: ", errorInfo.error.message]
      })
    }), !errorInfo && /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
      __unstable_focusRing: true,
      as: "button",
      onClick: handleOpen,
      padding: 3,
      radius: 2,
      tone: MARKER_TONE[marker.level],
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        align: "flex-start",
        gap: 3,
        children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          flex: "none",
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            size: 1,
            children: React.createElement(MARKER_ICON[marker.level])
          })
        }), /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
          flex: 1,
          space: 2,
          children: [/* @__PURE__ */jsxRuntime.jsx(DocumentNodePathBreadcrumbs, {
            path: marker.path,
            schemaType,
            value
          }), /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            muted: true,
            size: 1,
            children: marker.item.message
          })]
        })]
      })
    })]
  });
}
function DocumentNodePathBreadcrumbs(props) {
  const {
    path,
    schemaType,
    value
  } = props;
  const pathTypes = React.useMemo(() => getPathTypes({
    path,
    schemaType,
    value
  }), [path, schemaType, value]);
  return /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
    size: 1,
    children: pathTypes.map((t, i) => /* @__PURE__ */jsxRuntime.jsxs(React.Fragment, {
      children: [i > 0 && /* @__PURE__ */jsxRuntime.jsx("span", {
        style: {
          color: "var(--card-muted-fg-color)",
          opacity: 0.5
        },
        children: " / "
      }), /* @__PURE__ */jsxRuntime.jsx("span", {
        style: {
          fontWeight: 500
        },
        children: t.title || t.name
      })]
    }, i))
  });
}
function useMenuItem(props) {
  const {
    documentId,
    documentType
  } = props;
  const {
    validation: validationMarkers
  } = sanity.useValidationStatus(documentId, documentType);
  const validation = React.useMemo(() => validationMarkers.map(item => ({
    level: item.level,
    message: item.item.message,
    path: item.path
  })), [validationMarkers]);
  const hasErrors = validation.some(sanity.isValidationError);
  const hasWarnings = validation.some(sanity.isValidationWarning);
  const icon = React.useMemo(() => {
    if (hasErrors) return icons.ErrorOutlineIcon;
    if (hasWarnings) return icons.WarningOutlineIcon;
    return icons.CheckmarkCircleIcon;
  }, [hasErrors, hasWarnings]);
  const tone = React.useMemo(() => {
    if (hasErrors) return "critical";
    if (hasWarnings) return "caution";
    return "positive";
  }, [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: "Validation",
    tone,
    showAsAction: true
  };
}
const validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
};
const TIMELINE_LABELS = {
  create: "created",
  delete: "deleted",
  discardDraft: "discarded draft",
  initial: "created",
  editDraft: "edited",
  editLive: "live edited",
  publish: "published",
  unpublish: "unpublished"
};
const TIMELINE_ICON_COMPONENTS = {
  create: icons.AddCircleIcon,
  delete: icons.TrashIcon,
  discardDraft: icons.CloseIcon,
  initial: icons.AddCircleIcon,
  editDraft: icons.EditIcon,
  editLive: icons.EditIcon,
  publish: icons.PublishIcon,
  unpublish: icons.UnpublishIcon
};
function formatTimelineEventLabel(type) {
  return TIMELINE_LABELS[type];
}
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function UserAvatarStack(_ref28) {
  let {
    maxLength,
    userIds
  } = _ref28;
  return /* @__PURE__ */jsxRuntime.jsx(ui.AvatarStack, {
    maxLength,
    children: userIds.map(userId => /* @__PURE__ */jsxRuntime.jsx(sanity.UserAvatar, {
      user: userId,
      withTooltip: true
    }, userId))
  });
}
var __freeze$3 = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$i(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3, _b$1, _c$1, _d$1, _e, _f, _g;
const IconWrapper = styled__default.default(ui.Flex)(_ref29 => {
  let {
    theme
  } = _ref29;
  var _a2;
  const borderColor = (_a2 = theme.sanity.color.base.skeleton) == null ? void 0 : _a2.from;
  return styled.css(_a$3 || (_a$3 = __template$3(["\n    --timeline-hairline-width: 1px;\n    position: relative;\n    z-index: 2;\n    margin: 0;\n    padding: 0;\n\n    &::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: var(--timeline-hairline-width);\n      background: ", ";\n      top: 0;\n      left: calc((100% - var(--timeline-hairline-width)) / 2);\n      z-index: 1;\n    }\n  "])), borderColor);
});
const Root$2 = styled__default.default(ui.Button)(_ref30 => {
  let {
    $selected,
    $disabled
  } = _ref30;
  return styled.css(_d$1 || (_d$1 = __template$3(["\n    position: relative;\n    width: 100%;\n\n    /* Line styling */\n    &[data-first] ", "::before {\n      height: 50%;\n      top: unset;\n      bottom: 0;\n    }\n\n    &[data-last] ", "::before {\n      height: 50%;\n    }\n\n    ", "\n\n    ", "\n  "])), IconWrapper, IconWrapper, $selected && styled.css(_b$1 || (_b$1 = __template$3(["\n      ", "::before {\n        background: transparent;\n      }\n    "])), IconWrapper), $disabled && styled.css(_c$1 || (_c$1 = __template$3(["\n      cursor: not-allowed;\n    "]))));
});
const IconBox = styled__default.default(ui.Box)(_e || (_e = __template$3(["\n  background: var(--card-bg-color);\n  border-radius: 50px;\n  position: relative;\n  z-index: 2;\n"])));
const EventLabel = styled__default.default(ui.Text)(_f || (_f = __template$3(["\n  text-transform: capitalize;\n"])));
const TimestampBox = styled__default.default(ui.Box)(_g || (_g = __template$3(["\n  min-width: 1rem;\n  margin-left: ", ";\n"])), _ref31 => {
  let {
    theme
  } = _ref31;
  return "-".concat(ui.rem(theme.sanity.space[1]));
});
const TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem(_ref32) {
  let {
    chunk,
    isFirst,
    isLast,
    isLatest,
    isSelected,
    onSelect,
    timestamp,
    type
  } = _ref32;
  const iconComponent = getTimelineEventIconComponent(type);
  const authorUserIds = Array.from(chunk.authors);
  const isSelectable = type !== "delete";
  const formattedTimestamp = React.useMemo(() => {
    const parsedDate = new Date(timestamp);
    const formattedDate = dateFns.format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [timestamp]);
  const handleClick = React.useCallback(evt => {
    evt.preventDefault();
    evt.stopPropagation();
    if (isSelectable) {
      onSelect(chunk);
    }
  }, [onSelect, chunk, isSelectable]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$2, {
    $selected: isSelected,
    $disabled: !isSelectable,
    "data-chunk-id": chunk.id,
    "data-first": isFirst ? true : void 0,
    "data-last": isLast ? true : void 0,
    "data-ui": "timelineItem",
    mode: isSelected ? "default" : "bleed",
    onClick: handleClick,
    padding: 0,
    radius: 2,
    tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
    children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
      paddingX: 2,
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        align: "stretch",
        children: [/* @__PURE__ */jsxRuntime.jsx(IconWrapper, {
          align: "center",
          children: /* @__PURE__ */jsxRuntime.jsx(IconBox, {
            padding: 2,
            children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
              size: 2,
              children: iconComponent && React.createElement(iconComponent)
            })
          })
        }), /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
          space: 2,
          margin: 2,
          children: [isLatest && /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
            children: /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: /* @__PURE__ */jsxRuntime.jsx(ui.Label, {
                muted: true,
                size: 0,
                children: "Latest"
              })
            })
          }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
            children: /* @__PURE__ */jsxRuntime.jsx(EventLabel, {
              size: 1,
              weight: "medium",
              children: formatTimelineEventLabel(type) || /* @__PURE__ */jsxRuntime.jsx("code", {
                children: type
              })
            })
          }), /* @__PURE__ */jsxRuntime.jsx(TimestampBox, {
            paddingX: 1,
            children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
              size: 0,
              muted: true,
              children: formattedTimestamp
            })
          })]
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
          flex: 1,
          justify: "flex-end",
          align: "center",
          children: /* @__PURE__ */jsxRuntime.jsx(UserAvatarStack, {
            maxLength: 3,
            userIds: authorUserIds
          })
        })]
      })
    })
  });
}
var __freeze$2 = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$h(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2, _b, _c, _d;
const StackWrapper = styled__default.default(ui.Stack)(_a$2 || (_a$2 = __template$2(["\n  max-width: 200px;\n"])));
const ListWrapper = styled__default.default(ui.Flex)(_b || (_b = __template$2(["\n  max-height: calc(100vh - 198px);\n  min-width: 244px;\n"])));
const Root$1 = styled__default.default(ui.Box)(_ref33 => {
  let {
    $visible
  } = _ref33;
  return styled.css(_d || (_d = __template$2(["\n    opacity: 0;\n    pointer-events: none;\n\n    ", "\n  "])), $visible && styled.css(_c || (_c = __template$2(["\n      opacity: 1;\n      pointer-events: auto;\n    "]))));
});
const Timeline = _ref34 => {
  let {
    chunks,
    disabledBeforeFirstChunk,
    hasMoreChunks,
    lastChunk,
    onLoadMore,
    onSelect,
    firstChunk
  } = _ref34;
  const [mounted, setMounted] = React.useState(false);
  const filteredChunks = React.useMemo(() => {
    return chunks.filter(c => {
      if (disabledBeforeFirstChunk && firstChunk) {
        return c.index < firstChunk.index;
      }
      return true;
    });
  }, [chunks, disabledBeforeFirstChunk, firstChunk]);
  const selectedIndex = React.useMemo(() => (lastChunk == null ? void 0 : lastChunk.id) ? filteredChunks.findIndex(c => c.id === lastChunk.id) : -1, [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]);
  const renderItem = React.useCallback((chunk, _ref35) => {
    let {
      activeIndex
    } = _ref35;
    const isFirst = activeIndex === 0;
    const isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
    return /* @__PURE__ */jsxRuntime.jsxs(ui.Box, {
      paddingBottom: isLast ? 1 : 0,
      paddingTop: isFirst ? 1 : 0,
      paddingX: 1,
      children: [/* @__PURE__ */jsxRuntime.jsx(TimelineItem, {
        chunk,
        isFirst,
        isLast,
        isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
        isSelected: activeIndex === selectedIndex,
        onSelect,
        timestamp: chunk.endTimestamp,
        type: chunk.type
      }), activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
        align: "center",
        justify: "center",
        padding: 4,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Spinner, {
          muted: true
        })
      })]
    });
  }, [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]);
  React.useEffect(() => setMounted(true), []);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$1, {
    $visible: !selectedIndex || mounted,
    "data-ui": "timeline",
    children: [filteredChunks.length === 0 && /* @__PURE__ */jsxRuntime.jsxs(StackWrapper, {
      padding: 3,
      space: 3,
      children: [/* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        size: 1,
        weight: "semibold",
        children: "No document history"
      }), /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
        muted: true,
        size: 1,
        children: "When changing the content of the document, the document versions will appear in this menu."
      })]
    }), filteredChunks.length > 0 && /* @__PURE__ */jsxRuntime.jsx(ListWrapper, {
      direction: "column",
      children: /* @__PURE__ */jsxRuntime.jsx(sanity.CommandList, {
        activeItemDataAttr: "data-hovered",
        ariaLabel: "Document revisions",
        autoFocus: "list",
        initialIndex: selectedIndex,
        initialScrollAlign: "center",
        itemHeight: 40,
        items: filteredChunks,
        onEndReached: onLoadMore,
        onEndReachedIndexOffset: 20,
        overscan: 5,
        renderItem,
        wrapAround: false
      })
    })]
  });
};
Timeline.displayName = "Timeline";
function TimelineError() {
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
    align: "flex-start",
    gap: 3,
    padding: 4,
    children: [/* @__PURE__ */jsxRuntime.jsx(sanity.TextWithTone, {
      tone: "critical",
      children: /* @__PURE__ */jsxRuntime.jsx(icons.ErrorOutlineIcon, {})
    }), /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
      space: 4,
      children: [/* @__PURE__ */jsxRuntime.jsx(sanity.TextWithTone, {
        size: 1,
        tone: "critical",
        weight: "semibold",
        children: "An error occurred whilst retrieving document changes."
      }), /* @__PURE__ */jsxRuntime.jsx(sanity.TextWithTone, {
        size: 1,
        tone: "critical",
        children: "Document history transactions have not been affected."
      })]
    })]
  });
}
var __freeze$1 = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$g(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
const Root = styled__default.default(ui.Popover)(_a$1 || (_a$1 = __template$1(["\n  overflow: hidden;\n  overflow: clip;\n"])));
function TimelineMenu(_ref36) {
  let {
    chunk,
    mode,
    placement
  } = _ref36;
  const {
    setTimelineRange,
    setTimelineMode,
    timelineError,
    ready,
    timelineStore,
    isDeleted
  } = useDocumentPane();
  const [open, setOpen] = React.useState(false);
  const [button, setButton] = React.useState(null);
  const [popover, setPopover] = React.useState(null);
  const toast = ui.useToast();
  const chunks = sanity.useTimelineSelector(timelineStore, state => state.chunks);
  const loading = sanity.useTimelineSelector(timelineStore, state => state.isLoading);
  const hasMoreChunks = sanity.useTimelineSelector(timelineStore, state => state.hasMoreChunks);
  const realRevChunk = sanity.useTimelineSelector(timelineStore, state => state.realRevChunk);
  const sinceTime = sanity.useTimelineSelector(timelineStore, state => state.sinceTime);
  const handleOpen = React.useCallback(() => {
    setTimelineMode(mode);
    setOpen(true);
  }, [mode, setTimelineMode]);
  const handleClose = React.useCallback(() => {
    setTimelineMode("closed");
    setOpen(false);
  }, [setTimelineMode]);
  const handleClickOutside = React.useCallback(() => {
    if (open) {
      handleClose();
    }
  }, [handleClose, open]);
  const handleGlobalKeyDown = React.useCallback(event => {
    if (open && (event.key === "Escape" || event.key === "Tab")) {
      handleClose();
      button == null ? void 0 : button.focus();
    }
  }, [button, handleClose, open]);
  ui.useClickOutside(handleClickOutside, [button, popover]);
  ui.useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = React.useCallback(revChunk => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const selectSince = React.useCallback(sinceChunk => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: "Unable to load revision"
      });
    }
  }, [setTimelineMode, setTimelineRange, timelineStore, toast]);
  const handleLoadMore = React.useCallback(() => {
    if (!loading) {
      timelineStore.loadMore();
    }
  }, [loading, timelineStore]);
  const content = timelineError ? /* @__PURE__ */jsxRuntime.jsx(TimelineError, {}) : /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [mode === "rev" && /* @__PURE__ */jsxRuntime.jsx(Timeline, {
      chunks,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: realRevChunk,
      onLoadMore: handleLoadMore,
      onSelect: selectRev
    }), mode === "since" && /* @__PURE__ */jsxRuntime.jsx(Timeline, {
      chunks,
      disabledBeforeFirstChunk: true,
      firstChunk: realRevChunk,
      hasMoreChunks,
      lastChunk: sinceTime,
      onLoadMore: handleLoadMore,
      onSelect: selectSince
    })]
  });
  const timeLabel = useFormattedTimestamp((chunk == null ? void 0 : chunk.endTimestamp) || "");
  const revLabel = chunk ? "".concat(upperFirst__default.default(formatTimelineEventLabel(chunk.type)), ": ").concat(timeLabel) : "Latest version";
  const sinceLabel = chunk ? "Since: ".concat(timeLabel) : "Since: unknown version";
  const buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return /* @__PURE__ */jsxRuntime.jsx(Root, {
    constrainSize: true,
    content: open && content,
    "data-ui": "versionMenu",
    open,
    placement,
    portal: true,
    ref: setPopover,
    children: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
      disabled: !ready,
      mode: "bleed",
      fontSize: 1,
      padding: 2,
      iconRight: icons.SelectIcon,
      onClick: open ? handleClose : handleOpen,
      ref: setButton,
      selected: open,
      style: {
        maxWidth: "100%"
      },
      text: ready ? buttonLabel : "Loading history"
    })
  });
}
function useFormattedTimestamp(time) {
  const formatted = React.useMemo(() => {
    const parsedDate = time ? new Date(time) : /* @__PURE__ */new Date();
    const formattedDate = dateFns.format(parsedDate, "MMM d, yyyy, hh:mm a");
    return formattedDate;
  }, [time]);
  return formatted;
}
function LoadingContent() {
  return /* @__PURE__ */jsxRuntime.jsx(Delay, {
    ms: 300,
    children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      paddingTop: 3,
      children: [/* @__PURE__ */jsxRuntime.jsx(ui.Spinner, {
        muted: true
      }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
        marginTop: 3,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          align: "center",
          muted: true,
          size: 1,
          children: "Loading changes"
        })
      })]
    })
  });
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */new Map();
  sanity.visitDiff(diff, child => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation) {
      return true;
    }
    const {
      author,
      timestamp
    } = child.annotation;
    const previous = authorMap.get(author);
    if (!previous || previous.timestamp < timestamp) {
      authorMap.set(author, child.annotation);
    }
    return true;
  });
  return Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
var __freeze = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp$f(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
const Scroller = styled__default.default(sanity.ScrollContainer)(_a || (_a = __template(["\n  height: 100%;\n  overflow: auto;\n  position: relative;\n  scroll-behavior: smooth;\n"])));
function ChangesInspector(props) {
  const {
    onClose
  } = props;
  const {
    documentId,
    schemaType,
    timelineError,
    timelineStore,
    value
  } = useDocumentPane();
  const scrollRef = React.useRef(null);
  const diff = sanity.useTimelineSelector(timelineStore, state => state.diff);
  const onOlderRevision = sanity.useTimelineSelector(timelineStore, state => state.onOlderRevision);
  const selectionState = sanity.useTimelineSelector(timelineStore, state => state.selectionState);
  const sinceTime = sanity.useTimelineSelector(timelineStore, state => state.sinceTime);
  const loading = selectionState === "loading";
  const isComparingCurrent = !onOlderRevision;
  const documentContext = React__default.default.useMemo(() => ({
    documentId,
    schemaType,
    FieldWrapper: sanity.ChangeFieldWrapper,
    rootDiff: diff,
    isComparingCurrent,
    value
  }), [documentId, diff, isComparingCurrent, schemaType, value]);
  const changeAnnotations = React__default.default.useMemo(() => diff ? collectLatestAuthorAnnotations(diff) : [], [diff]);
  return /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
    "data-testid": "review-changes-pane",
    direction: "column",
    height: "fill",
    overflow: "hidden",
    children: [/* @__PURE__ */jsxRuntime.jsx(DocumentInspectorHeader, {
      as: "header",
      closeButtonLabel: "Close review changes",
      flex: "none",
      onClose,
      title: "Review changes",
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        gap: 1,
        padding: 3,
        paddingTop: 0,
        paddingBottom: 2,
        children: [/* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          flex: 1,
          children: /* @__PURE__ */jsxRuntime.jsx(TimelineMenu, {
            mode: "since",
            chunk: sinceTime,
            placement: "bottom-start"
          })
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          flex: "none",
          children: /* @__PURE__ */jsxRuntime.jsx(sanity.DiffTooltip, {
            annotations: changeAnnotations,
            description: "Changes by",
            portal: true,
            children: /* @__PURE__ */jsxRuntime.jsx(ui.AvatarStack, {
              maxLength: 4,
              "aria-label": "Changes by",
              children: changeAnnotations.map(_ref37 => {
                let {
                  author
                } = _ref37;
                return /* @__PURE__ */jsxRuntime.jsx(sanity.UserAvatar, {
                  user: author
                }, author);
              })
            })
          })
        })]
      })
    }), /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
      flex: 1,
      children: /* @__PURE__ */jsxRuntime.jsx(ui.BoundaryElementProvider, {
        element: scrollRef.current,
        children: /* @__PURE__ */jsxRuntime.jsx(Scroller, {
          "data-ui": "Scroller",
          ref: scrollRef,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
            flex: 1,
            padding: 4,
            children: /* @__PURE__ */jsxRuntime.jsx(Content, {
              diff,
              documentContext,
              error: timelineError,
              loading,
              schemaType
            })
          })
        })
      })
    })]
  });
}
function Content(_ref38) {
  let {
    error,
    diff,
    documentContext,
    loading,
    schemaType
  } = _ref38;
  if (error) {
    return /* @__PURE__ */jsxRuntime.jsx(sanity.NoChanges, {});
  }
  if (loading) {
    return /* @__PURE__ */jsxRuntime.jsx(LoadingContent, {});
  }
  if (!diff) {
    return /* @__PURE__ */jsxRuntime.jsx(sanity.NoChanges, {});
  }
  return /* @__PURE__ */jsxRuntime.jsx(sanity.DocumentChangeContext.Provider, {
    value: documentContext,
    children: /* @__PURE__ */jsxRuntime.jsx(sanity.ChangeList, {
      diff,
      schemaType
    })
  });
}
const changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const {
      features
    } = useDeskTool();
    return {
      hidden: !features.reviewChanges,
      icon: icons.RestoreIcon,
      title: "Review changes"
    };
  },
  component: ChangesInspector,
  onClose: _ref39 => {
    let {
      params
    } = _ref39;
    return {
      params: {
        ...params,
        since: void 0
      }
    };
  },
  onOpen: _ref40 => {
    let {
      params
    } = _ref40;
    return {
      params: {
        ...params,
        since: "@lastPublished"
      }
    };
  }
};
const documentActions = [PublishAction, UnpublishAction, DiscardChangesAction, DuplicateAction, DeleteAction, HistoryRestoreAction];
const documentBadges = [LiveEditBadge];
const inspectors = [validationInspector, changesInspector];
const deskTool = sanity.definePlugin(options => ({
  name: "@sanity/desk-tool",
  document: {
    actions: prevActions => {
      return Array.from( /* @__PURE__ */new Set([...prevActions, ...documentActions]));
    },
    badges: prevBadges => {
      return Array.from( /* @__PURE__ */new Set([...prevBadges, ...documentBadges]));
    },
    inspectors: prevInspectors => {
      return Array.from( /* @__PURE__ */new Set([...prevInspectors, ...inspectors]));
    }
  },
  tools: [{
    name: (options == null ? void 0 : options.name) || "desk",
    title: (options == null ? void 0 : options.title) || "Desk",
    icon: (options == null ? void 0 : options.icon) || icons.MasterDetailIcon,
    component: React.lazy(() => Promise.resolve().then(function () {
      return require('./index-4b6f5a04.js');
    }).then(function (n) {
      return n.index;
    })),
    canHandleIntent: (intent, params) => {
      return Boolean(intent === "edit" && params.id || intent === "create" && params.type || intent === "create" && params.template);
    },
    // Controlled by sanity/src/desk/components/deskTool/DeskTitle.tsx
    controlsDocumentTitle: true,
    getIntentState,
    options,
    router
  }]
}));
function getInspectorItems(_ref41) {
  let {
    currentInspector,
    hasValue,
    inspectors,
    inspectorMenuItems
  } = _ref41;
  return inspectors.map((inspector, index) => {
    var _a;
    const menuItem = inspectorMenuItems[index];
    if (!menuItem || menuItem.hidden) return null;
    return {
      action: "".concat(INSPECT_ACTION_PREFIX).concat(inspector.name),
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a = menuItem.hotkeys) == null ? void 0 : _a.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem(_ref42) {
  let {
    hasValue
  } = _ref42;
  return {
    action: "inspect",
    group: "inspectors",
    title: "Inspect",
    icon: icons.BinaryDocumentIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem(_ref43) {
  let {
    previewUrl
  } = _ref43;
  if (!previewUrl) return null;
  return {
    action: "production-preview",
    group: "links",
    title: "Open preview",
    icon: icons.EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  };
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params);
  const items = [
  // Get production preview item
  getProductionPreviewItem(params)].filter(Boolean);
  return [...inspectorItems,
  // TODO: convert to inspector or document view?
  getInspectItem(params), ...items];
}
const isSanityDocument = value => sanity.isRecord(value) && typeof value._id === "string" && typeof value._type === "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = React.useState(void 0);
  const [error, setError] = React.useState(null);
  const {
    resolveProductionUrl
  } = sanity.useSource().document;
  const value$ = reactRx.useAsObservable(value);
  if (error) throw error;
  React.useEffect(() => {
    value$.pipe(
    // this so that the preview URL isn't fetched on every keystroke
    operators.debounceTime(500), operators.switchMap(document => isSanityDocument(document) ? rxjs.from(resolveProductionUrl({
      document
    })) : rxjs.of(void 0)), operators.catchError(e => {
      const message = sanity.isRecord(e) && typeof e.message === "string" ? e.message : "Unknown error";
      throw new Error("An error was thrown while trying to get your preview url: ".concat(message));
    })).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]);
  return previewUrl;
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {};
  const structureNodeTemplate = opts.templateName;
  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    console.warn('Conflicting templates: URL says "'.concat(opts.urlTemplate, '", structure node says "').concat(structureNodeTemplate, '". Using "').concat(structureNodeTemplate, '".'));
  }
  const template = structureNodeTemplate || opts.urlTemplate;
  const typeTemplates = templates.filter(t => t.schemaType === opts.documentType);
  const templateParams = {
    ...opts.templateParams,
    ...(typeof payload === "object" ? payload || {} : {})
  };
  let templateName = template;
  if (!template && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }
  return {
    templateName,
    templateParams
  };
}
const InspectorMenuItem = React.memo(function InspectorMenuItem2(props) {
  const {
    documentId,
    documentType,
    index,
    setMenuItem,
    useMenuItem
  } = props;
  const node = sanity.useUnique(useMenuItem({
    documentId,
    documentType
  }));
  React.useEffect(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]);
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const {
    documentId,
    documentType,
    inspectors,
    onMenuItems
  } = props;
  const len = inspectors.length;
  const lenRef = React.useRef(len);
  const [menuItems, setMenuItems] = React.useState(() => Array.from(new Array(len)));
  const menuItemsRef = React.useRef(menuItems);
  React.useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++) {
        newFieldActions[i] = menuItemsRef.current[i];
      }
      lenRef.current = len;
      setMenuItems(() => {
        menuItemsRef.current = newFieldActions;
        return newFieldActions;
      });
    }
  }, [len]);
  const setMenuItem = React.useCallback((index, node) => {
    setMenuItems(prev => {
      const next = [...prev];
      next[index] = node;
      menuItemsRef.current = next;
      return next;
    });
  }, []);
  React.useEffect(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]);
  return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: inspectors.map((inspector, inspectorIndex) => inspector.useMenuItem && /* @__PURE__ */jsxRuntime.jsx(InspectorMenuItem, {
      documentId,
      documentType,
      index: inspectorIndex,
      setMenuItem,
      useMenuItem: inspector.useMenuItem
    }, inspector.name))
  });
}
const DocumentPaneProvider = React.memo(props => {
  const {
    children,
    index,
    pane,
    paneKey
  } = props;
  const schema = sanity.useSchema();
  const templates = sanity.useTemplates();
  const {
    actions: documentActions,
    badges: documentBadges,
    unstable_fieldActions: fieldActionsResolver,
    unstable_languageFilter: languageFilterResolver,
    inspectors: inspectorsResolver
  } = sanity.useSource().document;
  const presenceStore = sanity.usePresenceStore();
  const paneRouter = usePaneRouter();
  const setPaneParams = paneRouter.setParams;
  const {
    features
  } = useDeskTool();
  const {
    push: pushToast
  } = ui.useToast();
  const {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane;
  const paneOptions = sanity.useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = sanity.getPublishedId(documentIdRaw);
  const documentType = options.type;
  const params = sanity.useUnique(paneRouter.params) || EMPTY_PARAMS;
  const panePayload = sanity.useUnique(paneRouter.payload);
  const {
    templateName,
    templateParams
  } = React.useMemo(() => getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: params.template
  }), [documentType, paneOptions, params, panePayload, templates]);
  const initialValueRaw = sanity.useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  });
  const initialValue = sanity.useUnique(initialValueRaw);
  const {
    patch
  } = sanity.useDocumentOperation(documentId, documentType);
  const editState = sanity.useEditState(documentId, documentType);
  const {
    validation: validationRaw
  } = sanity.useValidationStatus(documentId, documentType);
  const connectionState = sanity.useConnectionState(documentId, documentType);
  const schemaType = schema.get(documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value;
  const [isDeleting, setIsDeleting] = React.useState(false);
  const [inspectorMenuItems, setInspectorMenuItems] = React.useState([]);
  const actions = React.useMemo(() => documentActions({
    schemaType: documentType,
    documentId
  }), [documentActions, documentId, documentType]);
  const badges = React.useMemo(() => documentBadges({
    schemaType: documentType,
    documentId
  }), [documentBadges, documentId, documentType]);
  const languageFilter = React.useMemo(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]);
  const validation = sanity.useUnique(validationRaw);
  const views = sanity.useUnique(viewsProp);
  const [focusPath, setFocusPath] = React.useState(() => params.path ? PathUtils.fromString(params.path) : []);
  const activeViewId = params.view || views[0] && views[0].id || null;
  const [timelineMode, setTimelineMode] = React.useState("closed");
  const [timelineError, setTimelineError] = React.useState(null);
  const timelineStore = sanity.useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  });
  const onOlderRevision = sanity.useTimelineSelector(timelineStore, state => state.onOlderRevision);
  const revTime = sanity.useTimelineSelector(timelineStore, state => state.revTime);
  const sinceAttributes = sanity.useTimelineSelector(timelineStore, state => state.sinceAttributes);
  const timelineDisplayed = sanity.useTimelineSelector(timelineStore, state => state.timelineDisplayed);
  const timelineReady = sanity.useTimelineSelector(timelineStore, state => state.timelineReady);
  const isPristine = sanity.useTimelineSelector(timelineStore, state => state.isPristine);
  const isDeleted = React.useMemo(() => {
    if (!timelineReady) {
      return false;
    }
    return Boolean(!(editState == null ? void 0 : editState.draft) && !(editState == null ? void 0 : editState.published)) && !isPristine;
  }, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]);
  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = React.useState([]);
  React.useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(nextPresence => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors = React.useMemo(() => inspectorsResolver({
    documentId,
    documentType
  }), [documentId, documentType, inspectorsResolver]);
  const [inspectorName, setInspectorName] = React.useState(() => params.inspect || null);
  const inspectParamRef = React.useRef(params.inspect);
  React.useEffect(() => {
    if (inspectParamRef.current !== params.inspect) {
      inspectParamRef.current = params.inspect;
      setInspectorName(params.inspect || null);
    }
  }, [params.inspect]);
  const currentInspector = inspectors == null ? void 0 : inspectors.find(i => i.name === inspectorName);
  const resolvedChangesInspector = inspectors.find(i => i.name === HISTORY_INSPECTOR_NAME);
  const changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME;
  const hasValue = Boolean(value);
  const menuItems = React.useMemo(() => getMenuItems({
    currentInspector,
    features,
    hasValue,
    inspectorMenuItems,
    inspectors,
    previewUrl
  }), [currentInspector, features, hasValue, inspectorMenuItems, inspectors, previewUrl]);
  const inspectOpen = params.inspect === "on";
  const compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null;
  const fieldActions = React.useMemo(() => schemaType ? fieldActionsResolver({
    documentId,
    documentType,
    schemaType
  }) : [], [documentId, documentType, fieldActionsResolver, schemaType]);
  const ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError);
  const displayed = React.useMemo(() => onOlderRevision ? timelineDisplayed || {
    _id: value._id,
    _type: value._type
  } : value, [onOlderRevision, timelineDisplayed, value]);
  const setTimelineRange = React.useCallback((newSince, newRev) => {
    setPaneParams({
      ...params,
      since: newSince,
      rev: newRev || void 0
    });
  }, [params, setPaneParams]);
  const handleFocus = React.useCallback(nextFocusPath => {
    setFocusPath(nextFocusPath);
    presenceStore.setLocation([{
      type: "document",
      documentId,
      path: nextFocusPath,
      lastActiveAt: /* @__PURE__ */new Date().toISOString()
    }]);
  }, [documentId, presenceStore, setFocusPath]);
  const handleBlur = React.useCallback(blurredPath => {
    setFocusPath([]);
  }, [setFocusPath]);
  const patchRef = React.useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = event => {
    patch.execute(sanity.toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = React.useCallback(event => patchRef.current(event), []);
  const closeInspector = React.useCallback(closeInspectorName => {
    var _a, _b, _c, _d;
    const inspector = closeInspectorName && inspectors.find(i => i.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn('No inspector named "'.concat(closeInspectorName, '"'));
      return;
    }
    if (!currentInspector) {
      return;
    }
    if (inspector) {
      const result = (_b = (_a = inspector.onClose) == null ? void 0 : _a.call(inspector, {
        params
      })) != null ? _b : {
        params
      };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({
        ...result.params,
        inspect: void 0
      });
      return;
    }
    if (currentInspector) {
      const result = (_d = (_c = currentInspector.onClose) == null ? void 0 : _c.call(currentInspector, {
        params
      })) != null ? _d : {
        params
      };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({
        ...result.params,
        inspect: void 0
      });
    }
  }, [currentInspector, inspectors, params, setPaneParams]);
  const openInspector = React.useCallback((nextInspectorName, paneParams) => {
    var _a, _b, _c, _d;
    const nextInspector = inspectors.find(i => i.name === nextInspectorName);
    if (!nextInspector) {
      console.warn('No inspector named "'.concat(nextInspectorName, '"'));
      return;
    }
    if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
      setPaneParams({
        ...params,
        ...paneParams,
        inspect: nextInspector.name
      });
      return;
    }
    let currentParams = params;
    if (currentInspector) {
      const closeResult = (_b = (_a = nextInspector.onClose) == null ? void 0 : _a.call(nextInspector, {
        params: currentParams
      })) != null ? _b : {
        params: currentParams
      };
      currentParams = closeResult.params;
    }
    const result = (_d = (_c = nextInspector.onOpen) == null ? void 0 : _c.call(nextInspector, {
      params: currentParams
    })) != null ? _d : {
      params: currentParams
    };
    setInspectorName(nextInspector.name);
    inspectParamRef.current = nextInspector.name;
    setPaneParams({
      ...result.params,
      ...paneParams,
      inspect: nextInspector.name
    });
  }, [currentInspector, inspectors, params, setPaneParams]);
  const handleHistoryClose = React.useCallback(() => {
    if (resolvedChangesInspector) {
      closeInspector(resolvedChangesInspector.name);
    }
  }, [closeInspector, resolvedChangesInspector]);
  const handleHistoryOpen = React.useCallback(() => {
    if (!features.reviewChanges) {
      return;
    }
    if (resolvedChangesInspector) {
      openInspector(resolvedChangesInspector.name);
    }
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]);
  const handlePaneClose = React.useCallback(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = React.useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleLegacyInspect = React.useCallback(function () {
    let toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !inspectOpen;
    if (toggle) {
      setPaneParams({
        ...params,
        inspect: "on"
      });
    } else {
      setPaneParams(omit__default.default(params, "inspect"));
    }
  }, [inspectOpen, params, setPaneParams]);
  const handleMenuAction = React.useCallback(item => {
    if (item.action === "production-preview" && previewUrl) {
      window.open(previewUrl);
      return true;
    }
    if (item.action === "inspect") {
      toggleLegacyInspect(true);
      return true;
    }
    if (item.action === "reviewChanges") {
      handleHistoryOpen();
      return true;
    }
    if (typeof item.action === "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
      const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length);
      const nextInspector = inspectors.find(i => i.name === nextInspectorName);
      if (nextInspector) {
        if (nextInspector.name === inspectorName) {
          closeInspector(nextInspector.name);
        } else {
          openInspector(nextInspector.name);
        }
        return true;
      }
    }
    return false;
  }, [closeInspector, handleHistoryOpen, inspectorName, inspectors, openInspector, previewUrl, toggleLegacyInspect]);
  const handleKeyUp = React.useCallback(event => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if (isHotkey__default.default(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          handleMenuAction(item);
          return;
        }
      }
    }
  }, [handleMenuAction, menuItems]);
  const handleLegacyInspectClose = React.useCallback(() => toggleLegacyInspect(false), [toggleLegacyInspect]);
  const [openPath, onSetOpenPath] = React.useState([]);
  const [fieldGroupState, onSetFieldGroupState] = React.useState();
  const [collapsedPaths, onSetCollapsedPath] = React.useState();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = React.useState();
  const handleOnSetCollapsedPath = React.useCallback((path, collapsed) => {
    onSetCollapsedPath(prevState => sanity.setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = React.useCallback((path, collapsed) => {
    onSetCollapsedFieldSets(prevState => sanity.setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = React.useCallback((path, groupName) => onSetFieldGroupState(prevState => sanity.setAtPath(prevState, path, groupName)), []);
  const requiredPermission = value._createdAt ? "update" : "create";
  const liveEdit = Boolean(schemaType == null ? void 0 : schemaType.liveEdit);
  const docId = value._id ? value._id : "dummy-id";
  const docPermissionsInput = React.useMemo(() => {
    return {
      ...value,
      _id: liveEdit ? sanity.getPublishedId(docId) : sanity.getDraftId(docId)
    };
  }, [liveEdit, value, docId]);
  const [permissions, isPermissionsLoading] = sanity.useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  });
  const isNonExistent = !(value == null ? void 0 : value._id);
  const readOnly = React.useMemo(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted);
    const updateActionDisabled = !_internal.isActionEnabled(schemaType, "update");
    const createActionDisabled = isNonExistent && !_internal.isActionEnabled(schemaType, "create");
    const reconnecting = connectionState === "reconnecting";
    const isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [connectionState, editState.transactionSyncLock, isNonExistent, isDeleted, isDeleting, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, ready, revTime, schemaType]);
  const formState = sanity.useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  });
  const formStateRef = React.useRef(formState);
  formStateRef.current = formState;
  const setOpenPath = React.useCallback(path => {
    const ops = sanity.getExpandOperations(formStateRef.current, path);
    ops.forEach(op => {
      if (op.type === "expandPath") {
        onSetCollapsedPath(prevState => sanity.setAtPath(prevState, op.path, false));
      }
      if (op.type === "expandFieldSet") {
        onSetCollapsedFieldSets(prevState => sanity.setAtPath(prevState, op.path, false));
      }
      if (op.type === "setSelectedGroup") {
        onSetFieldGroupState(prevState => sanity.setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    closeInspector,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState,
    fieldActions,
    focusPath,
    inspector: currentInspector || null,
    inspectors,
    menuItems,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onPathOpen: setOpenPath,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleLegacyInspectClose,
    onKeyUp: handleKeyUp,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup: handleSetActiveFieldGroup,
    onSetCollapsedPath: handleOnSetCollapsedPath,
    onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
    openInspector,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType,
    isPermissionsLoading,
    permissions,
    setTimelineMode,
    setTimelineRange,
    setIsDeleting,
    isDeleting,
    isDeleted,
    timelineError,
    timelineMode,
    timelineStore,
    title,
    value,
    views,
    formState,
    unstable_languageFilter: languageFilter
  };
  React.useEffect(() => {
    if (connectionState === "reconnecting") {
      pushToast({
        id: "sanity/desk/reconnecting",
        status: "warning",
        title: /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
          children: "Connection lost. Reconnecting\u2026"
        })
      });
    }
  }, [connectionState, pushToast]);
  React.useEffect(() => {
    var _a;
    if (ready && params.path) {
      const {
        path,
        ...restParams
      } = params;
      const pathFromUrl = PathUtils.resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, PathUtils.fromString(path));
      setFocusPath(pathFromUrl);
      setOpenPath(pathFromUrl);
      paneRouter.setParams(restParams);
    }
  }, [params, documentId, setOpenPath, ready, paneRouter]);
  const [rootFieldActionNodes, setRootFieldActionNodes] = React.useState([]);
  return /* @__PURE__ */jsxRuntime.jsxs(DocumentPaneContext.Provider, {
    value: documentPane,
    children: [inspectors.length > 0 && /* @__PURE__ */jsxRuntime.jsx(DocumentInspectorMenuItemsResolver, {
      documentId,
      documentType,
      inspectors,
      onMenuItems: setInspectorMenuItems
    }), fieldActions.length > 0 && schemaType && /* @__PURE__ */jsxRuntime.jsx(sanity.FieldActionsResolver, {
      actions: fieldActions,
      documentId,
      documentType,
      onActions: setRootFieldActionNodes,
      path: sanity.EMPTY_ARRAY,
      schemaType
    }), /* @__PURE__ */jsxRuntime.jsx(sanity.FieldActionsProvider, {
      actions: rootFieldActionNodes,
      path: sanity.EMPTY_ARRAY,
      children
    })]
  });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
var __defProp$e = Object.defineProperty;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$e = (obj, key, value) => {
  __defNormalProp$e(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class SerializeError extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    __publicField$e(this, "path");
    __publicField$e(this, "helpId");
    const segment = typeof pathSegment === "undefined" ? "<unknown>" : "".concat(pathSegment);
    this.path = (parentPath || []).concat(hint ? "".concat(segment, " (").concat(hint, ")") : segment);
  }
  withHelpUrl(id) {
    this.helpId = id;
    return this;
  }
}
var HELP_URL = /* @__PURE__ */(HELP_URL2 => {
  HELP_URL2["ID_REQUIRED"] = "structure-node-id-required";
  HELP_URL2["TITLE_REQUIRED"] = "structure-title-required";
  HELP_URL2["FILTER_REQUIRED"] = "structure-filter-required";
  HELP_URL2["INVALID_LIST_ITEM"] = "structure-invalid-list-item";
  HELP_URL2["COMPONENT_REQUIRED"] = "structure-view-component-required";
  HELP_URL2["DOCUMENT_ID_REQUIRED"] = "structure-document-id-required";
  HELP_URL2["DOCUMENT_TYPE_REQUIRED"] = "structure-document-type-required";
  HELP_URL2["SCHEMA_TYPE_REQUIRED"] = "structure-schema-type-required";
  HELP_URL2["SCHEMA_TYPE_NOT_FOUND"] = "structure-schema-type-not-found";
  HELP_URL2["LIST_ITEMS_MUST_BE_ARRAY"] = "structure-list-items-must-be-array";
  HELP_URL2["QUERY_PROVIDED_FOR_FILTER"] = "structure-query-provided-for-filter";
  HELP_URL2["ACTION_OR_INTENT_REQUIRED"] = "structure-action-or-intent-required";
  HELP_URL2["LIST_ITEM_IDS_MUST_BE_UNIQUE"] = "structure-list-item-ids-must-be-unique";
  HELP_URL2["ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE"] = "structure-action-and-intent-mutually-exclusive";
  HELP_URL2["API_VERSION_REQUIRED_FOR_CUSTOM_FILTER"] = "structure-api-version-required-for-custom-filter";
  return HELP_URL2;
})(HELP_URL || {});
const IMPLICIT_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType)) {
    return "";
  }
  const schemaField = schemaType.fields.find(field => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_FIELDS.includes(head)) {
      console.warn('The current ordering config targeted the nonexistent field "%s" on schema type "%s". It should be one of %o', head, schemaType.name, schemaType.fields.map(field => field.name));
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return "".concat(head, "->{").concat(refTypes.map(refType => joinReferences(refType, tail)).join(","), "}");
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail);
  const tailWrapper = tailFields ? "{".concat(tailFields, "}") : "";
  return tail.length > 0 ? "".concat(head).concat(tailWrapper) : head;
}
function getExtendedProjection(schemaType, orderBy) {
  return orderBy.map(ordering => joinReferences(schemaType, ordering.field.split("."))).join(", ");
}
const ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  name: "lastEditedDesc",
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
};
const ORDER_BY_CREATED_AT = {
  title: "Created",
  name: "lastCreatedDesc",
  by: [{
    field: "_createdAt",
    direction: "desc"
  }]
};
const DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
const DEFAULT_ORDERING_OPTIONS = [ORDER_BY_UPDATED_AT,
// _updatedAt
ORDER_BY_CREATED_AT
// _createdAt
];

var __defProp$d = Object.defineProperty;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$d = (obj, key, value) => {
  __defNormalProp$d(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
class MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    /** menu item option object. See {@link PartialMenuItem} */
    __publicField$d(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({
      action
    });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({
      intent
    });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /**
   * Get menu item title
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({
      group
    });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({
      params
    });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction() {
    let showAsAction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      showAsAction: Boolean(showAsAction)
    });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      title,
      action,
      intent
    } = this.spec;
    if (!title) {
      const hint = typeof action === "string" ? 'action: "'.concat(action, '"') : void 0;
      throw new SerializeError("`title` is required for menu item", options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent) {
      throw new SerializeError("`action` or `intent` required for menu item with title ".concat(this.spec.title), options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    }
    if (intent && action) {
      throw new SerializeError("cannot set both `action` AND `intent`", options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    }
    return {
      ...this.spec,
      title
    };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new MenuItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
function getOrderingMenuItem(context, ordering, extendedProjection) {
  return new MenuItemBuilder(context).group("sorting").title("Sort by ".concat(ordering.title)).icon(icons.SortIcon).action("setSortOrder").params({
    by: ordering.by,
    extendedProjection
  });
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const {
    schema
  } = context;
  const type = typeof typeName === "string" ? schema.get(typeName) : typeName;
  if (!type || !("orderings" in type)) {
    return [];
  }
  return (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map(ordering => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
var __defProp$c = Object.defineProperty;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$c = (obj, key, value) => {
  __defNormalProp$c(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({
    path,
    index
  }) : item;
}
class MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context;
    /** Menu item group ID */
    __publicField$c(this, "_id");
    /** Menu item group title */
    __publicField$c(this, "_title");
    this._id = spec ? spec.id : "";
    this._title = spec ? spec.title : "";
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new MenuItemGroupBuilder(this._context, {
      id,
      title: this._title
    });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new MenuItemGroupBuilder(this._context, {
      id: this._id,
      title
    });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      _id,
      _title
    } = this;
    if (!_id) {
      throw new SerializeError("`id` is required for a menu item group", options.path, options.index, _title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!_title) {
      throw new SerializeError("`title` is required for a menu item group", options.path, _id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return {
      id: _id,
      title: _title
    };
  }
}
const disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id !== "string") {
    throw new SerializeError("Structure node id must be of type string, got ".concat(typeof id), parentPath, pathSegment);
  }
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar) {
    throw new SerializeError('Structure node id cannot contain character "'.concat(disallowedChar, '"'), parentPath, pathSegment);
  }
  if (id.startsWith("__edit__")) {
    throw new SerializeError("Structure node id cannot start with __edit__", parentPath, pathSegment);
  }
  return id;
}
function getStructureNodeId(title, id) {
  if (id) {
    return id;
  }
  const camelCased = camelCase__default.default(title);
  return disallowedPattern.test(camelCased) ? camelCase__default.default(speakingurl__default.default(title)) : camelCased;
}
var __defProp$b = Object.defineProperty;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$b = (obj, key, value) => {
  __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ComponentBuilder {
  constructor(spec) {
    /** component builder option object */
    __publicField$b(this, "spec");
    this.spec = {
      options: {},
      ...(spec ? spec : {})
    };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component) {
    return this.clone({
      component
    });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({
      options
    });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child,
      options: componentOptions,
      component
    } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!component) {
      throw new SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, options.path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, options.path))
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new ComponentBuilder();
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type";
  const documentId = sanity.getPublishedId(id);
  const draftId = sanity.getDraftId(id);
  const types = await getClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(query, {
    documentId,
    draftId
  }, {
    tag: "structure.resolve-type"
  });
  return types[0];
}
var __defProp$a = Object.defineProperty;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$a = (obj, key, value) => {
  __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class GenericViewBuilder {
  constructor() {
    /** Generic view option object */
    __publicField$a(this, "spec", {});
  }
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({
      title,
      id: this.spec.id || kebabCase__default.default(title)
    });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      icon
    } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!title) {
      throw new SerializeError("`title` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
}
function isSerializable(view) {
  return typeof view.serialize === "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({
    path,
    index
  }) : item;
}
var __defProp$9 = Object.defineProperty;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$9 = (obj, key, value) => {
  __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const isComponentSpec = spec => sanity.isRecord(spec) && spec.type === "component";
class ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? {
      ...componentOrSpec
    } : {
      options: {}
    };
    super();
    /** Partial Component view option object. See {@link ComponentView} */
    __publicField$9(this, "spec");
    this.spec = spec;
    const userComponent = typeof componentOrSpec === "function" ? componentOrSpec : this.spec.component;
    if (userComponent) {
      this.spec = this.component(userComponent).spec;
    }
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component) {
    return this.clone({
      component
    });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({
      options
    });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const base = super.serialize(options);
    const component = this.spec.component;
    if (typeof component !== "function") {
      throw new SerializeError("`component` is required and must be a function for `component()` view item", options.path, options.index).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    }
    return {
      ...base,
      component,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new ComponentViewBuilder();
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$8 = (obj, key, value) => {
  __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super();
    /** Document list options. See {@link FormView} */
    __publicField$8(this, "spec");
    this.spec = {
      id: "editor",
      title: "Editor",
      ...(spec ? spec : {})
    };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new FormViewBuilder();
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
const form = spec => new FormViewBuilder(spec);
const component = componentOrSpec => new ComponentViewBuilder(componentOrSpec);
var views = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ComponentViewBuilder: ComponentViewBuilder,
  FormViewBuilder: FormViewBuilder,
  GenericViewBuilder: GenericViewBuilder,
  component: component,
  form: form,
  maybeSerializeView: maybeSerializeView
});
var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$7 = (obj, key, value) => {
  __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const createDocumentChildResolver = _ref44 => {
  let {
    resolveDocumentNode,
    getClient
  } = _ref44;
  return async (itemId, _ref45) => {
    let {
      params,
      path
    } = _ref45;
    let type = params.type;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];
    if (!type) {
      type = await resolveTypeForDocument(getClient, itemId);
    }
    if (!type) {
      throw new SerializeError("Failed to resolve document, and no type provided in parameters.", parentPath, currentSegment);
    }
    return resolveDocumentNode({
      documentId: itemId,
      schemaType: type
    });
  };
};
class DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context;
    /** Component builder option object See {@link PartialDocumentNode} */
    __publicField$7(this, "spec");
    this.spec = spec ? spec : {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...(this.spec.options || {}),
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...(this.spec.options || {}),
        type: typeof documentType === "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...(this.spec.options || {}),
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views) {
    return this.clone({
      views
    });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const urlId = path[index || path.length - 1];
    const id = this.spec.id || urlId && "".concat(urlId) || "";
    const options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for document nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options || !options.id) {
      throw new SerializeError("document id (`id`) is required for document nodes", path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    }
    if (!options || !options.type) {
      throw new SerializeError("document type (`schemaType`) is required for document nodes", path, id, hint);
    }
    const views = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
    const viewIds = views.map(view => view.id);
    const dupes = uniq__default.default(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0) {
      throw new SerializeError("document node has views with duplicate IDs: ".concat(dupes.join(",  ")), path, id, hint);
    }
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const builder = new DocumentBuilder(this._context);
    const options = {
      ...(this.spec.options || {}),
      ...(withSpec.options || {})
    };
    builder.spec = {
      ...this.spec,
      ...withSpec,
      options
    };
    return builder;
  }
}
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  if (spec.template) {
    opts.template = spec.template;
  }
  if (spec.templateParameters) {
    opts.templateParameters = spec.templateParameters;
  }
  return opts;
}
function documentFromEditor(context, spec) {
  let doc = (spec == null ? void 0 : spec.type) ?
  // Use user-defined document fragment as base if possible
  context.resolveDocumentNode({
    schemaType: spec.type
  }) :
  // Fall back to plain old document builder
  new DocumentBuilder(context);
  if (!spec) return doc;
  const {
    id,
    type,
    template,
    templateParameters
  } = spec.options;
  doc = doc.id(spec.id).documentId(id);
  if (type) {
    doc = doc.schemaType(type);
  }
  if (template) {
    doc = doc.initialValueTemplate(template, templateParameters);
  }
  if (spec.child) {
    doc = doc.child(spec.child);
  }
  return doc;
}
function documentFromEditorWithInitialValue(_ref46, templateId, parameters) {
  let {
    resolveDocumentNode,
    templates
  } = _ref46;
  const template = templates.find(t => t.id === templateId);
  if (!template) {
    throw new Error('Template with ID "'.concat(templateId, '" not defined'));
  }
  return resolveDocumentNode({
    schemaType: template.schemaType
  }).initialValueTemplate(templateId, parameters);
}
const layoutOptions = ["default", "card", "media", "detail", "block"];
const DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent");
const defaultIntentChecker = (intentName, params, _ref47) => {
  let {
    pane
  } = _ref47;
  var _a, _b;
  const isEdit = intentName === "edit";
  const isCreate = intentName === "create";
  const typedSpec = pane;
  const paneFilter = ((_a = typedSpec.options) == null ? void 0 : _a.filter) || "";
  const paneParams = ((_b = typedSpec.options) == null ? void 0 : _b.params) || {};
  const typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams);
  const initialValueTemplates = typedSpec.initialValueTemplates || [];
  if (isCreate && params.template) {
    return initialValueTemplates.some(tpl => tpl.templateId === params.template);
  }
  return isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$6 = (obj, key, value) => {
  __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    /** Initial Value template item option object. See {@link InitialValueTemplateItem} */
    __publicField$6(this, "spec");
    this.spec = spec ? spec : {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({
      description
    });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({
      parameters
    });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      spec,
      _context
    } = this;
    const {
      templates
    } = _context;
    if (typeof spec.id !== "string" || !spec.id) {
      throw new SerializeError("`id` is required for initial value template item nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!spec.templateId) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const template = templates.find(t => t.id === spec.templateId);
    if (!template) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template.description,
      title: spec.title || template.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const builder = new InitialValueTemplateItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...withSpec
    };
    return builder;
  }
}
function defaultInitialValueTemplateItems(context) {
  const {
    schema,
    getStructureBuilder,
    templates
  } = context;
  const typeNames = schema.getTypeNames();
  const ordered = templates.filter(tpl => {
    var _a;
    return !((_a = tpl.parameters) == null ? void 0 : _a.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType));
  return ordered.map(tpl => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const {
    schema,
    templates
  } = context;
  return templateItems.map(item => {
    const template = templates.find(t => t.id === item.templateId);
    const title = item.title || (template == null ? void 0 : template.title) || "Create new";
    const params = pickBy__default.default({
      type: template && template.schemaType,
      template: item.templateId
    }, Boolean);
    const intentParams = item.parameters ? [params, item.parameters] : params;
    const schemaType = template && schema.get(template.schemaType);
    return new MenuItemBuilder(context).title(title).icon(template && template.icon || (schemaType == null ? void 0 : schemaType.icon) || icons.ComposeIcon).intent({
      type: "create",
      params: intentParams
    }).serialize();
  });
}
var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function noChildResolver() {
  return void 0;
}
const shallowIntentChecker = (intentName, params, _ref48) => {
  let {
    pane,
    index
  } = _ref48;
  return index <= 1 && defaultIntentChecker(intentName, params, {
    pane,
    index
  });
};
class GenericListBuilder {
  constructor() {
    /** Check if initial value templates are set */
    __publicField$5(this, "initialValueTemplatesSpecified", false);
    /** Generic list option object */
    __publicField$5(this, "spec", {});
  }
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({
      defaultLayout
    });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({
      canHandleIntent
    });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      displayOptions: {
        ...(this.spec.displayOptions || {}),
        showIcons: enabled
      }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    this.initialValueTemplatesSpecified = true;
    return this.clone({
      initialValueTemplates: Array.isArray(templates) ? templates : [templates]
    });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const id = this.spec.id || "";
    const path = options.path;
    const defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout)) {
      throw new SerializeError("`layout` must be one of ".concat(layoutOptions.map(item => '"'.concat(item, '"')).join(", ")), path, id || options.index, this.spec.title);
    }
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map((item, i) => maybeSerializeInitialValueTemplateItem(item, i, path));
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, path))
    };
  }
}
var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const validateFilter = (spec, options) => {
  var _a;
  const filter = ((_a = spec.options) == null ? void 0 : _a.filter.trim()) || "";
  if (["*", "{"].includes(filter[0])) {
    throw new SerializeError("`filter` cannot start with `".concat(filter[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }
  return filter;
};
const createDocumentChildResolverForItem = context => (itemId, options) => {
  var _a;
  const parentItem = options.parent;
  const template = ((_a = options.params) == null ? void 0 : _a.template) ? context.templates.find(tpl => tpl.id === options.params.template) : void 0;
  const type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then(schemaType => schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId: itemId
  }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType(""));
};
class DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    /** Document list options. See {@link PartialDocumentList} */
    __publicField$4(this, "spec");
    this.spec = spec || {};
    this.initialValueTemplatesSpecified = Boolean(spec == null ? void 0 : spec.initialValueTemplates);
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({
      options: {
        ...(this.spec.options || {
          filter: ""
        }),
        apiVersion
      }
    });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.apiVersion;
  }
  /** Set Document list filter
   * @param filter - filter
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter) {
    return this.clone({
      options: {
        ...(this.spec.options || {}),
        filter
      }
    });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type === "string" ? type : type.name;
    return this.clone({
      schemaTypeName
    });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: {
        ...(this.spec.options || {
          filter: ""
        }),
        params
      }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error("`defaultOrdering` must be an array of order clauses");
    }
    return this.clone({
      options: {
        ...(this.spec.options || {
          filter: ""
        }),
        defaultOrdering: ordering
      }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    var _a;
    if (typeof this.spec.id !== "string" || !this.spec.id) {
      throw new SerializeError("`id` is required for document lists", options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!this.spec.options || !this.spec.options.filter) {
      throw new SerializeError("`filter` is required for document lists", options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    }
    const hasSimpleFilter = ((_a = this.spec.options) == null ? void 0 : _a.filter) === "_type == $type";
    if (!hasSimpleFilter && this.spec.options.filter && !this.spec.options.apiVersion) {
      console.warn("No apiVersion specified for document type list with custom filter: `".concat(this.spec.options.filter, "`. This will be required in the future. See %s for more info."), generateHelpUrl.generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER));
    }
    return {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
        apiVersion: this.spec.options.apiVersion || sanity.DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
    }
    if (!builder.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }
    return builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
}
function inferInitialValueTemplates(context, spec) {
  const {
    document
  } = context;
  const {
    schemaTypeName,
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: "",
    params: {}
  };
  const typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter, params)));
  if (typeNames.length === 0) {
    return void 0;
  }
  return typeNames.flatMap(schemaType => document.resolveNewDocumentOptions({
    type: "structure",
    schemaType
  })).map(option => ({
    ...option,
    icon: icons.ComposeIcon
  }));
}
function inferTypeName(spec) {
  const {
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: "",
    params: {}
  };
  const typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let typeNames = getTypeNamesFromEqualityFilter(filter, params);
  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter, params);
  }
  return typeNames;
}
function getTypeNamesFromEqualityFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  const matches = [];
  let match;
  while ((match = pattern.exec(filter)) !== null) {
    matches.push(match[1] || match[2]);
  }
  return matches.map(candidate => {
    const typeName = candidate[0] === "$" ? params[candidate.slice(1)] : candidate;
    const normalized = (typeName || "").trim().replace(/^["']|["']$/g, "");
    return normalized;
  }).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const pattern = /\b_type\s+in\s+\[(.*?)\]/;
  const matches = filter.match(pattern);
  if (!matches) {
    return [];
  }
  return matches[1].split(/,\s*/).map(match => match.trim().replace(/^["']+|["']+$/g, "")).map(item => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean);
}
var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const getArgType = thing => {
  if (thing instanceof ListBuilder) {
    return "ListBuilder";
  }
  if (isPromise(thing)) {
    return "Promise";
  }
  return Array.isArray(thing) ? "array" : typeof thing;
};
const isListItem = item => {
  return item.type === "listItem";
};
const defaultCanHandleIntent = (intentName, params, context) => {
  const pane = context.pane;
  const items = pane.items || [];
  return items.filter(isDocumentListItem).some(item => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
};
const resolveChildForItem = (itemId, options) => {
  const parentItem = options.parent;
  const items = parentItem.items.filter(isListItem);
  const target = (items.find(item => item.id === itemId) || {
    child: void 0
  }).child;
  if (!target || typeof target !== "function") {
    return target;
  }
  return typeof target === "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder) {
    return item.serialize({
      path,
      index
    });
  }
  const listItem = item;
  if (listItem && listItem.type === "divider") {
    return item;
  }
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem);
    const helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError('List items must be of type "listItem", got "'.concat(gotWhat, '"').concat(helpText), path, index).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return sanity.isRecord(thing) && typeof thing.then === "function";
}
class ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    /** buildable list option object. See {@link BuildableList} */
    __publicField$3(this, "spec");
    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({
      items
    });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const id = this.spec.id;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const items = typeof this.spec.items === "undefined" ? [] : this.spec.items;
    if (!Array.isArray(items)) {
      throw new SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    }
    const path = (options.path || []).concat(id);
    const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
    const dupes = serializedItems.filter((val, i) => find__default.default(serializedItems, {
      id: val.id
    }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map(item => item.id).slice(0, 5);
      const dupeDesc = dupes.length > 5 ? "".concat(dupeIds.join(", "), "...") : dupeIds.join(", ");
      throw new SerializeError("List items with same ID found (".concat(dupeDesc, ")"), options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new ListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    /** List item option object. See {@link PartialListItem} */
    __publicField$2(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      displayOptions: {
        ...(this.spec.displayOptions || {}),
        showIcon: enabled
      }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({
      schemaType
    });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      return this._context.schema.get(schemaType);
    }
    return this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child
    } = this.spec;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options.titleIsOptional && (typeof title !== "string" || !title)) {
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    let schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      const type = this._context.schema.get(schemaType);
      if (!type) {
        throw new SerializeError('Could not find type "'.concat(schemaType, '" in schema'), options.path, id).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      }
      schemaType = type;
    }
    const serializeOptions = {
      path: options.path.concat(id),
      hint: "child"
    };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild === "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => {
        return originalChild(itemId, {
          ...childOptions,
          serializeOptions
        });
      };
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new ListItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const createDefaultChildResolver = (context, spec) => documentId => {
  const schemaType = spec.schemaType && (typeof spec.schemaType === "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId
  }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
class DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec);
    this._context = _context;
    /** Document list options. See {@link PartialDocumentListItem} */
    __publicField$1(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const spec = super.serialize({
      ...options,
      titleIsOptional: true
    });
    if (!spec.schemaType) {
      throw new SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    }
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return {
      ...spec,
      child,
      schemaType: spec.schemaType,
      _id: spec.id
    };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListItemBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...(withSpec || {})
    };
    return builder;
  }
}
function isDocumentListItem(item) {
  return sanity.isRecord(item) && typeof item.schemaType !== "undefined" && typeof item._id === "string";
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context);
    this._context = _context;
    /** Document list options. See {@link PartialDocumentList} */
    __publicField(this, "spec");
    this.spec = spec ? spec : {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({
      child
    });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new DocumentTypeListBuilder(this._context);
    builder.spec = {
      ...this.spec,
      ...parent.getSpec(),
      ...(withSpec || {})
    };
    return builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new DocumentTypeListBuilder(this._context);
    const canHandleIntent = this.spec.canHandleIntent;
    const shouldOverride = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER;
    const override = shouldOverride ? {
      canHandleIntent: void 0
    } : {};
    builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...(withSpec || {}),
      ...override
    };
    return builder;
  }
}
function shouldShowIcon(schemaType) {
  const preview = schemaType.preview;
  return Boolean(preview && (preview.prepare || preview.select && preview.select.media));
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a;
  return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes(_ref49) {
  let {
    schema
  } = _ref49;
  return schema.getTypeNames().filter(n => {
    const schemaType = schema.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter(n => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map(typeName => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const {
    schema
  } = context;
  const type = schema.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || startCase__default.default(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find(item => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }
    return list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const {
    schema,
    resolveDocumentNode
  } = context;
  const schemaType = typeof typeNameOrSpec === "string" ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === "string" ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === "string" ? {
    schemaType
  } : typeNameOrSpec;
  const type = schema.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || startCase__default.default(typeName);
  const showIcons = shouldShowIcon(type);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({
    type: typeName
  }).schemaType(type).showIcons(showIcons).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{
    id: "sorting",
    title: "Sort"
  }, {
    id: "layout",
    title: "Layout"
  }, {
    id: "actions",
    title: "Actions"
  }]).child(spec.child || (documentId => resolveDocumentNode({
    schemaType: typeName,
    documentId
  }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [
  // Create new (from action button) will be added in serialization step of GenericList
  // Sort by <Y>
  ...getOrderingMenuItemsForSchemaType(context, type),
  // Display as <Z>
  new MenuItemBuilder(context).group("layout").title("Compact view").icon(icons.StackCompactIcon).action("setLayout").params({
    layout: "default"
  }), new MenuItemBuilder(context).group("layout").title("Detailed view").icon(icons.StackIcon).action("setLayout").params({
    layout: "detail"
  })
  // Create new (from menu) will be added in serialization step of GenericList
  ]);
}

function hasIcon(schemaType) {
  if (!schemaType || typeof schemaType === "string") {
    return false;
  }
  return Boolean(schemaType.icon);
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").items(items).showIcons(items.some(item => hasIcon(item.getSchemaType())));
}
function createStructureBuilder(_ref50) {
  let {
    defaultDocumentNode,
    source
  } = _ref50;
  const configContext = sanity.getConfigContextFromSource(source);
  const context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: options => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, {
        ...options,
        ...configContext
      })) || new DocumentBuilder(context);
      if (!builder.getId()) {
        builder = builder.id("documentEditor");
      }
      if (options.documentId) {
        builder = builder.documentId(sanity.getPublishedId(options.documentId));
      }
      return builder.schemaType(options.schemaType);
    }
  };
  const structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return getDocumentTypeList(context, ...args);
    },
    documentTypeListItem: function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return getDocumentTypeListItem(context, ...args);
    },
    documentTypeListItems: function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return getDocumentTypeListItems(context, ...args);
    },
    document: function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return new DocumentBuilder(context, ...args);
    },
    documentWithInitialValueTemplate: function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return documentFromEditorWithInitialValue(context, ...args);
    },
    defaultDocument: context.resolveDocumentNode,
    list: function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return new ListBuilder(context, ...args);
    },
    listItem: function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return new ListItemBuilder(context, ...args);
    },
    menuItem: function () {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return new MenuItemBuilder(context, ...args);
    },
    menuItemGroup: function () {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return new MenuItemGroupBuilder(context, ...args);
    },
    menuItemsFromInitialValueTemplateItems: function () {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return menuItemsFromInitialValueTemplateItems(context, ...args);
    },
    documentList: function () {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return new DocumentListBuilder(context, ...args);
    },
    documentListItem: function () {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return new DocumentListItemBuilder(context, ...args);
    },
    orderingMenuItem: function () {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return getOrderingMenuItem(context, ...args);
    },
    orderingMenuItemsForType: function () {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return getOrderingMenuItemsForSchemaType(context, ...args);
    },
    editor: function () {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return documentFromEditor(context, ...args);
    },
    defaultInitialValueTemplateItems: function () {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return defaultInitialValueTemplateItems(context, ...args);
    },
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: spec => {
      return reactIs.isValidElementType(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec);
    },
    divider: () => ({
      id: uniqueId__default.default("__divider__"),
      type: "divider"
    }),
    view: views,
    context
  };
  return structureBuilder;
}
function DeskToolProvider(_ref51) {
  let {
    defaultDocumentNode,
    structure: resolveStructure,
    children
  } = _ref51;
  const [layoutCollapsed, setLayoutCollapsed] = React.useState(false);
  const source = sanity.useSource();
  const configContext = sanity.useConfigContextFromSource(source);
  const documentStore = sanity.useDocumentStore();
  const S = React.useMemo(() => {
    return createStructureBuilder({
      defaultDocumentNode,
      source
    });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = React.useMemo(() => {
    if (resolveStructure) return resolveStructure(S, {
      ...configContext,
      documentStore
    });
    return S.defaults();
  }, [S, resolveStructure, configContext, documentStore]);
  const features = React.useMemo(() => ({
    backButton: layoutCollapsed,
    resizablePanes: !layoutCollapsed,
    reviewChanges: !layoutCollapsed,
    splitPanes: !layoutCollapsed,
    splitViews: !layoutCollapsed
  }), [layoutCollapsed]);
  const deskTool = React.useMemo(() => {
    return {
      features,
      layoutCollapsed,
      setLayoutCollapsed,
      rootPaneNode,
      structureContext: S.context
    };
  }, [features, layoutCollapsed, rootPaneNode, S.context]);
  return /* @__PURE__ */jsxRuntime.jsx(DeskToolContext.Provider, {
    value: deskTool,
    children
  });
}
exports.BackLink = BackLink;
exports.ChildLink = ChildLink;
exports.ComponentBuilder = ComponentBuilder;
exports.ComponentViewBuilder = ComponentViewBuilder;
exports.ConfirmDeleteDialogContainer = ConfirmDeleteDialogContainer;
exports.DEFAULT_INTENT_HANDLER = DEFAULT_INTENT_HANDLER;
exports.DOCUMENT_INSPECTOR_MAX_WIDTH = DOCUMENT_INSPECTOR_MAX_WIDTH;
exports.DOCUMENT_INSPECTOR_MIN_WIDTH = DOCUMENT_INSPECTOR_MIN_WIDTH;
exports.DOCUMENT_PANEL_INITIAL_MIN_WIDTH = DOCUMENT_PANEL_INITIAL_MIN_WIDTH;
exports.DOCUMENT_PANEL_MIN_WIDTH = DOCUMENT_PANEL_MIN_WIDTH;
exports.DOCUMENT_PANEL_PORTAL_ELEMENT = DOCUMENT_PANEL_PORTAL_ELEMENT;
exports.Delay = Delay;
exports.DeskToolProvider = DeskToolProvider;
exports.DocTitle = DocTitle;
exports.DocumentBuilder = DocumentBuilder;
exports.DocumentInspectorHeader = DocumentInspectorHeader;
exports.DocumentListBuilder = DocumentListBuilder;
exports.DocumentListItemBuilder = DocumentListItemBuilder;
exports.DocumentPaneProvider = DocumentPaneProvider;
exports.DocumentTypeListBuilder = DocumentTypeListBuilder;
exports.FormViewBuilder = FormViewBuilder;
exports.GenericListBuilder = GenericListBuilder;
exports.GenericViewBuilder = GenericViewBuilder;
exports.HELP_URL = HELP_URL;
exports.HistoryRestoreAction = HistoryRestoreAction;
exports.InitialValueTemplateItemBuilder = InitialValueTemplateItemBuilder;
exports.LOADING_PANE = LOADING_PANE;
exports.ListBuilder = ListBuilder;
exports.ListItemBuilder = ListItemBuilder;
exports.MenuItemBuilder = MenuItemBuilder;
exports.MenuItemGroupBuilder = MenuItemGroupBuilder;
exports.PANE_COLLAPSED_WIDTH = PANE_COLLAPSED_WIDTH;
exports.PANE_DEFAULT_MIN_WIDTH = PANE_DEFAULT_MIN_WIDTH;
exports.Pane = Pane;
exports.PaneContent = PaneContent;
exports.PaneContextMenuButton = PaneContextMenuButton;
exports.PaneFooter = PaneFooter;
exports.PaneHeader = PaneHeader;
exports.PaneHeaderActionButton = PaneHeaderActionButton;
exports.PaneHeaderActions = PaneHeaderActions;
exports.PaneItemPreview = PaneItemPreview;
exports.PaneLayoutContext = PaneLayoutContext;
exports.PaneRouterContext = PaneRouterContext;
exports.ParameterizedLink = ParameterizedLink;
exports.ReferenceChildLink = ReferenceChildLink;
exports.Resizable = Resizable;
exports.Root = Root$6;
exports.SerializeError = SerializeError;
exports.TimelineMenu = TimelineMenu;
exports._DEBUG = _DEBUG;
exports.component = component;
exports.createStructureBuilder = createStructureBuilder;
exports.defaultInitialValueTemplateItems = defaultInitialValueTemplateItems;
exports.defaultIntentChecker = defaultIntentChecker;
exports.deskTool = deskTool;
exports.documentFromEditor = documentFromEditor;
exports.documentFromEditorWithInitialValue = documentFromEditorWithInitialValue;
exports.form = form;
exports.getOrderingMenuItem = getOrderingMenuItem;
exports.getOrderingMenuItemsForSchemaType = getOrderingMenuItemsForSchemaType;
exports.getTypeNamesFromFilter = getTypeNamesFromFilter;
exports.isDocumentListItem = isDocumentListItem;
exports.isMenuNodeButton = isMenuNodeButton;
exports.isNotMenuNodeButton = isNotMenuNodeButton;
exports.maybeSerializeInitialValueTemplateItem = maybeSerializeInitialValueTemplateItem;
exports.maybeSerializeMenuItem = maybeSerializeMenuItem;
exports.maybeSerializeMenuItemGroup = maybeSerializeMenuItemGroup;
exports.maybeSerializeView = maybeSerializeView;
exports.menuItemsFromInitialValueTemplateItems = menuItemsFromInitialValueTemplateItems;
exports.resolveMenuNodes = resolveMenuNodes;
exports.setActivePanes = setActivePanes;
exports.shallowIntentChecker = shallowIntentChecker;
exports.useDeskTool = useDeskTool;
exports.useDocumentPane = useDocumentPane;
exports.usePane = usePane;
exports.usePaneLayout = usePaneLayout;
exports.usePaneRouter = usePaneRouter;
//# sourceMappingURL=desk-aad5f038.js.map
